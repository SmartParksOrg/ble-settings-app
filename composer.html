<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Settings HEX Composer</title>
  <link rel="stylesheet" href="style.css" />
  <script src="functions.js"></script>
</head>

<body>
  <div id="header-section">
  <h1>Settings HEX Composer</h1>

  <div class="controls">
    <label for="settings-dropdown">Choose a settings file:</label>
    <select id="settings-dropdown" onchange="loadSelectedFile()"></select>
  </div>
  </div>

  <div id="settings-section"></div>

  <div id="floating-bar">
    <select id="payload-type" onchange="updateEncodedMessage()">
      <option value="lorawan">LoRaWAN (port 3)</option>
      <option value="rockblock">RockBlock</option>
      <option value="ble">BLE custom command</option>
    </select>
    <input type="text" id="hex-output" readonly value="(no settings selected)" />
    <button id="copy-button" onclick="copyToClipboard()">ðŸ“‹</button>
  </div>

  <script>
    // ---------------------------------------------
    // Load and Display Settings
    // ---------------------------------------------
    async function loadSelectedFile() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      await loadSettings(selectedFile);
      displaySettings();
      updateEncodedMessage(); // Update once shown
    }

    function displaySettings() {
      const settingsSection = document.getElementById('settings-section');
      settingsSection.innerHTML = '';

      const groupedSettings = groupAndSortSettings(settingsData.settings);

      for (const [groupName, group] of Object.entries(groupedSettings)) {
        const settingsContainer = document.createElement('div');
        settingsContainer.className = 'settings-container';

        const groupHeading = document.createElement('h3');
        groupHeading.textContent = groupName.replace(/_/g, "");
        settingsSection.appendChild(groupHeading);

        for (const [key, setting] of Object.entries(group)) {
          // Create the top-level container
          const row = document.createElement('div');
          row.className = 'setting transparent';
          row.setAttribute('id', `setting-${setting.id}`);

          // Build the "include" checkbox + label
          row.innerHTML = `
            <div class="checkbox-container">
              <input type="checkbox" id="checkbox-${setting.id}" onchange="updateCheckBox(this)"/>
              <label for="checkbox-${setting.id}"><h4>${key} <small>(${setting.id})</small></h4></label>
            </div>${renderInput(key, setting)}
          `;

          settingsContainer.appendChild(row);
        }

        settingsSection.appendChild(settingsContainer);
      }
    }

    function onInputChanged(setting, value, valid) {
      updateEncodedMessage();
    }

    function updateCheckBox(element) {
      if (element.checked) {
        element.parentElement.parentElement.classList.remove('transparent');
      } else {
        element.parentElement.parentElement.classList.add('transparent');
      }
      updateEncodedMessage();
    }

    // ---------------------------------------------
    // Build final payload
    // ---------------------------------------------
    function updateEncodedMessage() {
      const hexOutput = document.getElementById('hex-output');
      const payloadType = document.getElementById('payload-type');

      const encodedBytes = [];
      hexOutput.classList.remove('invalid');

      // Iterate each known setting
      for (const [intId, val] of settingsMap) {
        const [settingKey, settingObj] = val;

        // The top-level "include" checkbox
        const checkbox = document.getElementById(`checkbox-${settingObj.id}`);
        if (!checkbox || !checkbox.checked) {
          continue; // user didn't select it
        }

        // Convert to bytes
        let valueBytes;
        try {
          valueBytes = settingToBytes(settingObj, getInputValue(settingObj.id));
        } catch (error) {
          hexOutput.value = `Error: ${error.message}`;
          hexOutput.classList.add('invalid');
          return;
        }

        // Example format: [settingId, length, valueBytes...]
        const length = valueBytes.length;
        const idInt = parseInt(settingObj.id, 16);

        encodedBytes.push(idInt, length, ...valueBytes);
      }

      // If nothing is selected
      if (encodedBytes.length === 0) {
        hexOutput.value = '(no settings selected)';
        return;
      }

      // Depending on payloadType
      if (payloadType.value === 'lorawan') {
        hexOutput.value = bytesToHex(encodedBytes);
      } else if (payloadType.value === 'rockblock') {
        // Example: prepend 0x03 for rockblock
        encodedBytes.unshift(0x03);
        hexOutput.value = bytesToHex(encodedBytes);
      } else if (payloadType.value === 'ble') {
        // Example: prepend 0x03 for BLE
        encodedBytes.unshift(0x03);
        hexOutput.value = encodedBytes.map(b => '0x' + toHex(b)).join(' ');
      }
    }

    // Copy to clipboard
    function copyToClipboard() {
      updateEncodedMessage();
      const hexOutput = document.getElementById('hex-output');
      navigator.clipboard.writeText(hexOutput.value).then(() => {
        // optionally provide feedback
      }).catch(err => {
        console.error('Could not copy text: ', err);
      });
    }

    populateSettingsIntoPage();

    // Load first file on page load
    loadSelectedFile();
  </script>
</body>

</html>