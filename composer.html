<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Settings HEX Composer</title>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(reg => console.log('Service Worker registered:', reg))
        .catch(err => console.error('Service Worker registration failed:', err));
    }
  </script>
  <link rel="stylesheet" href="style.css" />
  <link rel="manifest" href="composer-manifest.json">
  <script src="functions.js"></script>
</head>

<body>
  <div id="header-section" class="page-section">
    <div class="brand">
      <img src="assets/smart-parks-logo.png" alt="Smart Parks" class="brand-logo" />
      <div class="brand-title">
        <span class="brand-name">Smart Parks</span>
        <span class="brand-subtitle">Settings HEX Composer</span>
      </div>
    </div>
    <div class="controls">
      <div class="header-actions">
        <div class="header-select">
          <select id="settings-dropdown" onchange="loadSelectedFile()"></select>
        </div>
        <div class="button-cluster">
          <input type="file" id="import-file" onchange="importFromJson()" style="display: none;" />
        </div>
      </div>
    </div>
  </div>

  <div id="settings-area" class="settings-section page-section">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon hw-version" aria-hidden="true"></span>Settings</summary>
      <div class="section-card-body">
        <button id="import-button" class="section-action" onclick="document.getElementById('import-file').click();">Import settings</button>
        <div class="settings-options">
          <label class="settings-option">
            <input type="checkbox" id="composer-import-credentials-toggle">
            Include device credentials on import
          </label>
          <label class="settings-option">
            <input type="checkbox" id="composer-export-credentials-toggle">
            Include device credentials on export
          </label>
        </div>
        <div class="search">
          <input type="text" id="settings-search" placeholder="Search settings..." oninput="filterSettings()">
        </div>
        <div id="settings-section"></div>
      </div>
    </details>
  </div>

  <div id="composer-commands" class="commands-section page-section">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Commands</summary>
      <div class="section-card-body">
        <div id="commands-section"></div>
      </div>
    </details>
  </div>

  <div id="floating-bar">
    <select id="payload-type" onchange="updateEncodedMessage()">
      <option value="none">Payload type</option>
      <option value="lorawan" id="payload-lorawan">LoRaWAN</option>
      <option value="rockblock">RockBlock</option>
      <option value="ble">BLE custom command</option>
      <option value="file_export">File export</option>
    </select>
    <input type="text" id="hex-output" readonly value="(no settings selected)" />
    <button id="copy-button" onclick="copyToClipboard()" aria-label="Copy or export">
      <svg id="payload-icon" class="payload-icon" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet" aria-hidden="true" focusable="false">
        <path d="M224 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l160 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64L224 0zM64 128l64 0 0 64-64 0c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l192 0c17.7 0 32-14.3 32-32l0-64 64 0 0 64c0 53-43 96-96 96L64 576c-53 0-96-43-96-96l0-256c0-53 43-96 96-96z"/>
      </svg>
    </button>
  </div>

  <div id="import-preview-overlay" class="import-preview-overlay hidden" role="dialog" aria-modal="true"
    aria-labelledby="import-preview-title">
    <div class="import-preview-dialog">
      <div class="import-preview-header">
        <h3 id="import-preview-title">Import preview</h3>
        <p id="import-preview-subtitle"></p>
        <p id="import-preview-note" class="import-preview-note hidden"></p>
      </div>
      <div class="import-preview-body">
        <label class="import-preview-toggle">
          <input type="checkbox" id="import-preview-changed-only" checked>
          Show changed only
        </label>
        <table class="import-preview-table">
          <thead>
            <tr>
              <th>Setting</th>
              <th>Current</th>
              <th>New</th>
            </tr>
          </thead>
          <tbody id="import-preview-rows"></tbody>
        </table>
      </div>
      <div class="import-preview-footer">
        <button id="import-preview-cancel" class="secondary" type="button">Cancel</button>
        <button id="import-preview-confirm" type="button">Import</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <nav class="bottom-nav nav-4" aria-label="Primary">
    <a href="#header-section" class="nav-logo" aria-label="Smart Parks">
      <img src="assets/smart-parks-logo.png" alt="Smart Parks" />
    </a>
    <a href="#header-section" aria-label="Top" title="Top"><span class="icon square-caret-up" aria-hidden="true"></span></a>
    <a href="#settings-area" aria-label="Settings" title="Settings"><span class="icon hw-version" aria-hidden="true"></span></a>
    <a href="#composer-commands" aria-label="Commands" title="Commands"><span class="icon messages" aria-hidden="true"></span></a>
    <a href="index.html" aria-label="Home" title="Home"><span class="icon house" aria-hidden="true"></span></a>
  </nav>

  <footer class="app-version-footer">
    <span class="app-version" id="app-version">Version: loading...</span>
  </footer>

  <script>
    // ---------------------------------------------
    // Load and Display Settings
    // ---------------------------------------------
    async function loadSelectedFile() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      await loadSettings(selectedFile);
      displaySettings();
      displayCommands();
      updateEncodedMessage(); // Update once shown
    }

    const credentialSettingIds = new Set([0x10, 0x11, 0x12, 0x21, 0x2a, 0x44, 0x45, 0x46]);
    let lastPayloadType = 'none';

    function isCredentialSetting(setting) {
      if (!setting || !setting.id) {
        return false;
      }
      return credentialSettingIds.has(parseInt(setting.id, 16));
    }

    function sanitizeFilename(name) {
      const cleaned = (name || '').toString().trim().replace(/[^A-Za-z0-9_.-]/g, '');
      return cleaned || 'settings.json';
    }

    function ensureJsonExtension(name) {
      if (!name.toLowerCase().endsWith('.json')) {
        return `${name}.json`;
      }
      return name;
    }

    function getProposedFilename() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      const base = selectedFile ? selectedFile.split('/').pop().replace(/\.json$/i, '') : 'settings';
      return `${base}-compose.json`;
    }

    function buildSelectedSettingsPayload() {
      const settings = {};
      const includeCredentials = document.getElementById('composer-export-credentials-toggle')?.checked ?? true;

      if (!settingsData || !settingsData.settings) {
        return settings;
      }

      for (const [key, setting] of Object.entries(settingsData.settings)) {
        const checkbox = document.getElementById(`checkbox-${setting.id}`);
        if (!checkbox || !checkbox.checked) {
          continue; // user didn't select it
        }
        if (!includeCredentials && isCredentialSetting(setting)) {
          continue;
        }

        const value = getInputValue(setting.id);

        if (['uint32', 'uint16', 'uint8', 'int32', 'int8', 'float'].includes(setting.conversion)) {
          settings[key] = Number(value);
        } else if (setting.conversion === 'bool') {
          settings[key] = value === 'true';
        } else {
          settings[key] = value;
        }
      }

      return settings;
    }

    function hasSelectedCommands() {
      if (!settingsData || !settingsData.commands) {
        return false;
      }
      for (const [_, command] of Object.entries(settingsData.commands)) {
        const checkbox = document.getElementById(`checkbox-${command.id}`);
        if (checkbox && checkbox.checked) {
          return true;
        }
      }
      return false;
    }

    function downloadSettingsJson(settings, filename) {
      const json = JSON.stringify(settings, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function exportToJson(filename = 'settings.json') {
      if (hasSelectedCommands()) {
        showToast('Commands cannot be exported. Please deselect commands.');
        return;
      }
      const settings = buildSelectedSettingsPayload();
      if (Object.keys(settings).length === 0) {
        showToast('No settings selected to export');
        return;
      }

      const safeFilename = ensureJsonExtension(sanitizeFilename(filename));
      downloadSettingsJson(settings, safeFilename);
    }

    function showImportPreviewModal({ title, subtitle, rows, note }) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('import-preview-overlay');
        const titleEl = document.getElementById('import-preview-title');
        const subtitleEl = document.getElementById('import-preview-subtitle');
        const noteEl = document.getElementById('import-preview-note');
        const rowsEl = document.getElementById('import-preview-rows');
        const changedOnlyToggle = document.getElementById('import-preview-changed-only');
        const cancelBtn = document.getElementById('import-preview-cancel');
        const confirmBtn = document.getElementById('import-preview-confirm');

        titleEl.textContent = title;
        subtitleEl.textContent = subtitle;
        if (noteEl) {
          noteEl.textContent = note || '';
          noteEl.classList.toggle('hidden', !note);
        }
        function renderRows() {
          const changedOnly = changedOnlyToggle ? changedOnlyToggle.checked : false;
          rowsEl.innerHTML = rows.filter(row => !changedOnly || !row.unchanged).map((row) => `
          <tr class="${row.unchanged ? 'import-preview-unchanged' : ''}">
            <td>
              <div class="import-preview-setting">${row.name}</div>
              <div class="import-preview-meta">${row.key} (${row.id})</div>
              ${row.description ? `<div class="import-preview-desc">${row.description}</div>` : ''}
            </td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">${row.current}</td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">
              ${row.next}
              ${row.unchanged ? '<div class="import-preview-unchanged-tag">unchanged</div>' : ''}
            </td>
          </tr>
          `).join('');
        }
        renderRows();
        if (changedOnlyToggle) {
          changedOnlyToggle.onchange = renderRows;
        }

        function cleanup(result) {
          overlay.classList.add('hidden');
          cancelBtn.removeEventListener('click', onCancel);
          confirmBtn.removeEventListener('click', onConfirm);
          resolve(result);
        }

        function onCancel() {
          cleanup(false);
        }

        function onConfirm() {
          cleanup(true);
        }

        cancelBtn.addEventListener('click', onCancel);
        confirmBtn.addEventListener('click', onConfirm);
        overlay.classList.remove('hidden');
      });
    }

    async function importFromJson() {
      const fileInput = document.getElementById('import-file');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a file to import.');
        return;
      }

      displaySettings();
      console.log('Importing settings from file:', file.name);
      const reader = new FileReader();
      reader.onload = async function (event) {
        try {
          const entries = Object.entries(JSON.parse(event.target.result));
          const previewRows = [];
          const includeCredentials = document.getElementById('composer-import-credentials-toggle')?.checked ?? false;
          const filteredEntries = [];

          for (const [key, value] of entries) {
            const settingObj = getByKey(key);
            if (!settingObj) {
              continue;
            }
            if (!includeCredentials && isCredentialSetting(settingObj)) {
              continue;
            }
            const currentValue = getInputValue(settingObj.id) ?? settingObj.default;
            const unchanged = isSettingValueEqual(key, settingObj, currentValue, value);
            if (!unchanged) {
              filteredEntries.push([key, value]);
            }
            previewRows.push({
              key,
              id: settingObj.id,
              name: settingObj.display_name || key,
              description: getSettingDescription(key),
              current: formatSettingValueForPreview(key, settingObj, currentValue, value, 'current'),
              next: formatSettingValueForPreview(key, settingObj, value, currentValue, 'next'),
              unchanged
            });
          }

          if (previewRows.length === 0) {
            showToast('No valid settings found in the import file.');
            return;
          }
          if (filteredEntries.length === 0) {
            showToast('All selected settings already match the current values.');
            return;
          }

          const ok = await showImportPreviewModal({
            title: `Import ${previewRows.length} settings`,
            subtitle: `File: ${file.name}`,
            rows: previewRows,
            note: includeCredentials ? '' : 'Device credentials will be skipped.'
          });
          if (!ok) {
            showToast('Import cancelled');
            return;
          }

          for (const [key, value] of filteredEntries) {
            const settingObj = getByKey(key);
            if (settingObj) {
              const checkbox = document.getElementById(`checkbox-${settingObj.id}`);
              checkbox.checked = true;
              checkbox.parentElement.parentElement.classList.remove('transparent');
              setInputValue(settingObj.id, value);
            }
          }
        } catch (error) {
          console.error('Error importing settings:', error);
          showToast('Failed to import settings. Please check the file format.');
        }
      };
      reader.readAsText(file);
    }

    function displaySettings() {
      const settingsSection = document.getElementById('settings-section');
      settingsSection.innerHTML = '';

      const groupedSettings = groupAndSortSettings(settingsData.settings);

      for (const [groupName, group] of Object.entries(groupedSettings)) {
        const groupWrapper = document.createElement('div');
        groupWrapper.className = 'settings-group is-collapsed';

        const groupToggle = document.createElement('button');
        groupToggle.type = 'button';
        groupToggle.className = 'group-toggle';
        groupToggle.setAttribute('aria-expanded', 'false');
        groupToggle.innerHTML = `
          <span class="group-title">${groupName.replace(/_/g, " ")}</span>
          <span class="group-caret" aria-hidden="true"></span>
        `;
        groupToggle.addEventListener('click', () => toggleGroup(groupWrapper));

        const settingsContainer = document.createElement('div');
        settingsContainer.className = 'settings-container';

        for (const [key, setting] of Object.entries(group)) {
          // Create the top-level container
          const row = document.createElement('div');
          row.className = 'setting transparent';
          row.setAttribute('id', `setting-${setting.id}`);
          const settingDescription = getSettingDescription(key);
          row.setAttribute('data-search', `${key} ${setting.display_name} ${settingDescription}`.trim());

          // Build the "include" checkbox + label
          row.innerHTML = `
            <div class="checkbox-container">
              <input type="checkbox" id="checkbox-${setting.id}" onchange="updateCheckBox(this, '${setting.id}')"/>
              <label for="checkbox-${setting.id}"><h4 title="${key}">${setting.display_name} <small>${key} (${setting.id})</small></h4></label>
            </div>${renderInputContainer(key, setting)}
            ${settingDescription ? `<p class="setting-help">${settingDescription}</p>` : ""}
          `;

          settingsContainer.appendChild(row);
        }

        groupWrapper.appendChild(groupToggle);
        groupWrapper.appendChild(settingsContainer);
        settingsSection.appendChild(groupWrapper);
      }
    }

    function displayCommands() {
      const commandsSection = document.getElementById('commands-section');
      commandsSection.innerHTML = '';

      for (const [key, command] of Object.entries(settingsData.commands)) {
        if (dangerousCommands.some(rx => rx.test(key))) {
          continue;
        }

        // Create the top-level container
        const row = document.createElement('div');
        row.className = 'setting transparent';
        row.setAttribute('id', `setting-${command.id}`);

        // Build the "include" checkbox + label
        const commandLabel = getCommandLabel(key);
        const commandDescription = getCommandDescription(key);
        const commandInputMeta = getCommandInputMeta(key);
        let helperHtml = '';
        if (commandInputMeta && commandInputMeta.source === 'values') {
          const valueOptions = getCommandValueOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Value</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${valueOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        } else if (commandInputMeta && commandInputMeta.source === 'settings') {
          const settingOptions = getCommandSettingOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Setting</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${settingOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        }
        row.innerHTML = `
          <div class="checkbox-container">
            <input type="checkbox" id="checkbox-${command.id}" onchange="updateCheckBox(this, '${command.id}')"/>
            <label for="checkbox-${command.id}"><h4>${commandLabel} <small>${key} (${command.id})</small></h4></label>
          </div>${helperHtml ? `<div class="command-helper hidden" id="command-helper-${command.id}">${helperHtml}</div>` : ''}
          ${commandDescription ? `<p class="setting-help">${commandDescription}</p>` : ""}
        `;

        commandsSection.appendChild(row);
      }
    }

    function onInputChanged(setting, value, valid) {
      updateEncodedMessage();
    }

    function updateCheckBox(element, id) {
      if (element.checked) {
        element.parentElement.parentElement.classList.remove('transparent');
        setDefaultValue(id);
        const helper = document.getElementById(`command-helper-${id}`);
        if (helper) {
          helper.classList.remove('hidden');
        }
      } else {
        clearInputValue(id);
        element.parentElement.parentElement.classList.add('transparent');
        const helper = document.getElementById(`command-helper-${id}`);
        if (helper) {
          helper.classList.add('hidden');
          const selectEl = helper.querySelector('select');
          if (selectEl) {
            selectEl.selectedIndex = 0;
          }
          const inputEl = helper.querySelector('input');
          if (inputEl) {
            inputEl.value = '';
          }
        }
      }
      updateEncodedMessage();
    }

    const payloadIconPaths = {
      copy: {
        viewBox: '0 0 512 576',
        path: 'M224 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l160 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64L224 0zM64 128l64 0 0 64-64 0c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l192 0c17.7 0 32-14.3 32-32l0-64 64 0 0 64c0 53-43 96-96 96L64 576c-53 0-96-43-96-96l0-256c0-53 43-96 96-96z'
      },
      download: {
        viewBox: '0 0 512 512',
        path: 'M256 0c17.7 0 32 14.3 32 32l0 246.1 73.4-73.4c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3l-128 128c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l73.4 73.4L224 32c0-17.7 14.3-32 32-32zM64 416c0-17.7 14.3-32 32-32l320 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32z'
      }
    };

    function setPayloadIcon(mode) {
      const icon = document.getElementById('payload-icon');
      if (!icon || !payloadIconPaths[mode]) {
        return;
      }
      icon.setAttribute('viewBox', payloadIconPaths[mode].viewBox);
      icon.innerHTML = `<path d="${payloadIconPaths[mode].path}"></path>`;
    }

    // ---------------------------------------------
    // Build final payload
    // ---------------------------------------------
    function updateEncodedMessage() {
      const hexOutput = document.getElementById('hex-output');
      const payloadType = document.getElementById('payload-type');
      const actionButton = document.getElementById('copy-button');
      document.getElementById('payload-lorawan').innerHTML = `LoRaWAN`;

      const payloadValue = payloadType ? payloadType.value : 'none';

      if (payloadType == null || payloadValue === 'none') {
        hexOutput.value = '(please select a payload type)';
        hexOutput.readOnly = true;
        setPayloadIcon('copy');
        lastPayloadType = 'none';
        return;
      }

      if (payloadValue === 'file_export') {
        if (hasSelectedCommands()) {
          hexOutput.value = 'Error: Commands cannot be exported';
          hexOutput.classList.add('invalid');
          setPayloadIcon('copy');
          lastPayloadType = 'file_export';
          return;
        }
        const selectedSettings = buildSelectedSettingsPayload();
        const hasSelectedSettings = Object.keys(selectedSettings).length > 0;
        hexOutput.classList.remove('invalid');
        hexOutput.readOnly = false;
        setPayloadIcon('download');

        if (hasSelectedSettings) {
          if (lastPayloadType !== 'file_export' || hexOutput.value === '(no settings selected)') {
            hexOutput.value = getProposedFilename();
          } else if (!hexOutput.value.trim()) {
            hexOutput.value = getProposedFilename();
          }
        } else {
          hexOutput.value = '(no settings selected)';
        }

        lastPayloadType = 'file_export';
        return;
      }

      hexOutput.readOnly = true;
      setPayloadIcon('copy');
      lastPayloadType = payloadValue;

      const encodedBytes = [];
      hexOutput.classList.remove('invalid');

      const types = new Set();
      // Iterate each known setting
      for (const [intId, val] of settingsMap) {
        const [settingKey, settingObj] = val;

        // The top-level "include" checkbox
        const checkbox = document.getElementById(`checkbox-${settingObj.id}`);
        if (!checkbox || !checkbox.checked) {
          continue; // user didn't select it
        }

        types.add(settingObj.type);

        if (types.size > 1) {
          hexOutput.value = 'Error: Cannot mix different types';
          hexOutput.classList.add('invalid');
          return;
        }

        // Convert to bytes
        let valueBytes;
        try {
          if (settingObj.type === 'command' && settingObj.length === 1) {
            const selectEl = document.getElementById(`command-select-${settingObj.id}`);
            if (selectEl) {
              const selected = selectEl.value;
              const parsed = selected && selected.startsWith('0x') ? parseInt(selected, 16) : parseInt(selected, 10);
              valueBytes = settingToBytes(settingKey, settingObj, parsed.toString());
            } else {
              valueBytes = settingToBytes(settingKey, settingObj, getInputValue(settingObj.id));
            }
          } else {
            valueBytes = settingToBytes(settingKey, settingObj, getInputValue(settingObj.id));
          }
        } catch (error) {
          hexOutput.value = `Error (${settingKey}): ${error.message}`;
          hexOutput.classList.add('invalid');
          return;
        }

        // Example format: [settingId, length, valueBytes...]
        const length = valueBytes.length;
        const idInt = parseInt(settingObj.id, 16);

        encodedBytes.push(idInt, length, ...valueBytes);
      }

      // If nothing is selected
      if (encodedBytes.length === 0) {
        hexOutput.value = '(no settings selected)';
        return;
      }

      let port = 0;
      if (types.has("setting")) {
        port = 3;
      } else if (types.has("command")) {
        port = 32;
      } else {
        hexOutput.value = 'Error: Unknown type ' + types;
        hexOutput.classList.add('invalid');
        return;
      }

      // Depending on payloadType
      if (payloadType.value === 'lorawan') {
        hexOutput.value = bytesToHex(encodedBytes);
        document.getElementById('payload-lorawan').innerHTML = `LoRaWAN (port: ${port})`;
      } else if (payloadType.value === 'rockblock') {
        encodedBytes.unshift(port);
        hexOutput.value = bytesToHex(encodedBytes);
      } else if (payloadType.value === 'ble') {
        encodedBytes.unshift(port);
        hexOutput.value = encodedBytes.map(b => '0x' + toHex(b)).join(' ');
      }
    }

    // Copy to clipboard
    function copyToClipboard() {
      updateEncodedMessage();
      const payloadType = document.getElementById('payload-type');
      if (payloadType && payloadType.value === 'file_export') {
        const filenameInput = document.getElementById('hex-output').value;
        const filename = ensureJsonExtension(sanitizeFilename(filenameInput || getProposedFilename()));
        exportToJson(filename);
        return;
      }
      const hexOutput = document.getElementById('hex-output');
      navigator.clipboard.writeText(hexOutput.value).then(() => {
        showToast('Copied to clipboard');
      }).catch(err => {
        showToast('Failed to copy to clipboard');
        console.error('Could not copy text: ', err);
      });
    }

    populateSettingsIntoPage();

    // Load first file on page load
    loadSelectedFile();
  </script>
</body>

</html>
