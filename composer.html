<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Settings HEX Composer</title>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(reg => console.log('Service Worker registered:', reg))
        .catch(err => console.error('Service Worker registration failed:', err));
    }
  </script>
  <link rel="stylesheet" href="style.css" />
  <link rel="manifest" href="composer-manifest.json">
  <script src="functions.js"></script>
</head>

<body class="composer-page">
  <div id="header-section" class="page-section">
    <div class="header-top">
      <div class="brand">
        <img src="assets/smart-parks-logo.png" alt="Smart Parks" class="brand-logo" />
        <div class="brand-title">
          <span class="brand-name">Smart Parks</span>
          <span class="brand-subtitle">Settings HEX Composer</span>
        </div>
      </div>
      <div class="app-menu">
        <button id="app-menu-toggle" class="menu-toggle" aria-expanded="false" aria-controls="app-menu-panel" aria-label="Open menu">
          <svg class="menu-toggle-icon" viewBox="0 0 448 512" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M0 80C0 62.3 14.3 48 32 48l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 112C14.3 112 0 97.7 0 80zM0 240c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 272c-17.7 0-32-14.3-32-32zM448 400c0 17.7-14.3 32-32 32L32 432c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"/>
          </svg>
        </button>
        <div id="app-menu-panel" class="menu-panel" role="menu" aria-label="App menu">
          <a href="index.html" role="menuitem"><span class="icon house" aria-hidden="true"></span><span>Home</span></a>
        </div>
      </div>
    </div>
    <div class="controls">
      <div class="header-actions">
        <div class="header-select">
          <select id="settings-dropdown" onchange="loadSelectedFile()"></select>
        </div>
        <div class="button-cluster">
          <input type="file" id="import-file" onchange="importFromJson()" style="display: none;" />
        </div>
      </div>
    </div>
  </div>

  <div id="settings-area" class="settings-section page-section">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon gear" aria-hidden="true"></span>Settings</summary>
      <div class="section-card-body">
        <button id="import-button" class="section-action" onclick="document.getElementById('import-file').click();">Import settings</button>
        <div class="settings-options">
          <label class="settings-option">
            <input type="checkbox" id="composer-import-credentials-toggle">
            Include device credentials on import
          </label>
          <label class="settings-option">
            <input type="checkbox" id="composer-export-credentials-toggle">
            Include device credentials on export
          </label>
        </div>
        <div class="search">
          <input type="text" id="settings-search" placeholder="Search settings..." oninput="filterSettings()">
        </div>
        <div id="settings-section"></div>
      </div>
    </details>
  </div>

  <div id="composer-commands" class="commands-section page-section">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon play" aria-hidden="true"></span>Commands</summary>
      <div class="section-card-body">
        <div id="commands-section"></div>
      </div>
    </details>
  </div>

  <div id="composer-messenger" class="commands-section page-section">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon envelope" aria-hidden="true"></span>Messenger</summary>
      <div class="section-card-body messenger-card">
        <div class="messenger-meta">
          <span id="composer-messenger-port" class="messenger-pill">Port: -</span>
          <span class="messenger-pill">Payload: length + ASCII bytes</span>
        </div>
        <div class="messenger-input">
          <textarea id="composer-messenger-text" rows="2" placeholder="Type a message (ASCII, max 46)" oninput="updateComposerMessengerPayload()"></textarea>
          <span id="composer-messenger-count" class="messenger-limit messenger-limit-centered">0 / 46</span>
          <div class="messenger-send-row">
            <input type="text" id="composer-messenger-hex" class="messenger-payload-output" readonly value="(no message)" />
          </div>
          <div id="composer-messenger-error" class="input-helper"></div>
        </div>
      </div>
    </details>
  </div>

  <div id="composer-firmware-notes" class="commands-section page-section hidden">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon book" aria-hidden="true"></span>Firmware Notes</summary>
      <div class="section-card-body" id="composer-firmware-notes-body"></div>
    </details>
  </div>

  <div id="floating-bar">
    <select id="payload-type" onchange="updateEncodedMessage()">
      <option value="none">Payload type</option>
      <option value="lorawan" id="payload-lorawan">LoRaWAN</option>
      <option value="rockblock">RockBlock</option>
      <option value="ble">BLE custom command</option>
      <option value="file_export">File export</option>
    </select>
    <input type="text" id="hex-output" readonly value="(no settings selected)" />
    <button id="copy-button" onclick="copyToClipboard()" aria-label="Copy or export">
      <svg id="payload-icon" class="payload-icon" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet" aria-hidden="true" focusable="false">
        <path d="M224 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l160 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64L224 0zM64 128l64 0 0 64-64 0c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l192 0c17.7 0 32-14.3 32-32l0-64 64 0 0 64c0 53-43 96-96 96L64 576c-53 0-96-43-96-96l0-256c0-53 43-96 96-96z"/>
      </svg>
    </button>
  </div>

  <div id="import-preview-overlay" class="import-preview-overlay hidden" role="dialog" aria-modal="true"
    aria-labelledby="import-preview-title">
    <div class="import-preview-dialog">
      <div class="import-preview-header">
        <h3 id="import-preview-title">Import preview</h3>
        <p id="import-preview-subtitle"></p>
        <p id="import-preview-note" class="import-preview-note hidden"></p>
      </div>
      <div class="import-preview-body">
        <label class="import-preview-toggle">
          <input type="checkbox" id="import-preview-changed-only" checked>
          Show changed only
        </label>
        <table class="import-preview-table">
          <thead>
            <tr>
              <th>Setting</th>
              <th>Current</th>
              <th>New</th>
            </tr>
          </thead>
          <tbody id="import-preview-rows"></tbody>
        </table>
      </div>
      <div class="import-preview-footer">
        <button id="import-preview-cancel" class="secondary" type="button">Cancel</button>
        <button id="import-preview-confirm" type="button">Import</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <footer class="app-version-footer">
    <span class="app-version" id="app-version">Version: loading...</span>
  </footer>

  <script>
    function initAppMenu() {
      const toggle = document.getElementById('app-menu-toggle');
      const panel = document.getElementById('app-menu-panel');
      if (!toggle || !panel) {
        return;
      }
      const closeMenu = () => {
        panel.classList.remove('open');
        toggle.setAttribute('aria-expanded', 'false');
      };
      toggle.addEventListener('click', (event) => {
        event.stopPropagation();
        const isOpen = panel.classList.toggle('open');
        toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      });
      panel.querySelectorAll('a,button').forEach((item) => {
        item.addEventListener('click', () => {
          closeMenu();
        });
      });
      document.addEventListener('click', (event) => {
        if (!panel.classList.contains('open')) {
          return;
        }
        if (panel.contains(event.target) || toggle.contains(event.target)) {
          return;
        }
        closeMenu();
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeMenu();
        }
      });
    }

    // ---------------------------------------------
    // Load and Display Settings
    // ---------------------------------------------
    async function loadSelectedFile() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      try {
        await loadSettings(selectedFile);
        displaySettings();
        displayCommands();
        updateComposerMessengerMeta();
        updateComposerMessengerPayload();
        updateEncodedMessage(); // Update once shown
      } catch (error) {
        console.error(error);
        showToast(error.message || 'Failed to load settings file.');
      } finally {
        updateComposerFirmwareNotes(selectedFile);
      }
    }

    const credentialSettingIds = new Set([0x10, 0x11, 0x12, 0x21, 0x2a, 0x44, 0x45, 0x46]);
    let lastPayloadType = 'none';
    const COMPOSER_MESSAGING_MAX_LEN = 46;

    initAppMenu();

    let composerDeviceVersionNotes = null;
    let composerDeviceVersionNotesLoading = null;
    let composerDeviceVersionNotesError = null;

    function extractSettingsVersion(fileName) {
      if (!fileName) {
        return null;
      }
      const base = fileName.split('/').pop();
      const match = base.match(/v(\d+\.\d+\.\d+)/i) || base.match(/(\d+\.\d+\.\d+)/);
      return match ? match[1] : null;
    }

    function parseVersionString(version) {
      if (!version) {
        return null;
      }
      const parts = String(version).split('.').map((val) => parseInt(val, 10));
      if (!parts.length || parts.some((val) => Number.isNaN(val))) {
        return null;
      }
      return [
        parts[0] || 0,
        parts[1] || 0,
        parts[2] || 0
      ];
    }

    function compareVersionStrings(a, b) {
      const av = parseVersionString(a);
      const bv = parseVersionString(b);
      if (!av || !bv) {
        return 0;
      }
      for (let i = 0; i < 3; i++) {
        if (av[i] > bv[i]) return 1;
        if (av[i] < bv[i]) return -1;
      }
      return 0;
    }

    function loadDeviceVersionNotes() {
      if (composerDeviceVersionNotes) {
        return Promise.resolve(composerDeviceVersionNotes);
      }
      if (composerDeviceVersionNotesLoading) {
        return composerDeviceVersionNotesLoading;
      }
      composerDeviceVersionNotesError = null;
      composerDeviceVersionNotesLoading = fetch('device-version-notes.json', { cache: 'no-store' })
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Failed to load device-version-notes.json (${response.status})`);
          }
          return response.json();
        })
        .then((data) => {
          composerDeviceVersionNotes = data && Array.isArray(data.notes) ? data : { notes: [] };
          return composerDeviceVersionNotes;
        })
        .catch((error) => {
          console.warn('Device version notes unavailable', error);
          composerDeviceVersionNotesError = error;
          composerDeviceVersionNotes = { notes: [] };
          return composerDeviceVersionNotes;
        })
        .finally(() => {
          composerDeviceVersionNotesLoading = null;
        });
      return composerDeviceVersionNotesLoading;
    }

    function matchesDeviceNote(note, context) {
      const applies = note.appliesTo || {};
      const fwVersions = Array.isArray(applies.fwVersions) ? applies.fwVersions : [];
      const fwVersionMin = applies.fwVersionMin || null;
      const fwVersionMax = applies.fwVersionMax || null;
      if (fwVersions.length && (!context.fwVersion || !fwVersions.includes(context.fwVersion))) {
        return false;
      }
      if (fwVersionMin && (!context.fwVersion || compareVersionStrings(context.fwVersion, fwVersionMin) < 0)) {
        return false;
      }
      if (fwVersionMax && (!context.fwVersion || compareVersionStrings(context.fwVersion, fwVersionMax) > 0)) {
        return false;
      }
      return true;
    }

    function updateComposerFirmwareNotes(selectedFile) {
      const notesArea = document.getElementById('composer-firmware-notes');
      const notesBody = document.getElementById('composer-firmware-notes-body');
      if (!notesArea || !notesBody) {
        return;
      }
      if (!selectedFile) {
        notesArea.classList.add('hidden');
        notesBody.innerHTML = '';
        return;
      }
      const version = extractSettingsVersion(selectedFile);
      const context = { fwVersion: version };
      loadDeviceVersionNotes().then((data) => {
        const matching = data.notes.filter(note => matchesDeviceNote(note, context));
        if (!matching.length) {
          if (composerDeviceVersionNotesError && context.fwVersion) {
            notesBody.innerHTML = `
              <div class="data-item">
                <div>
                  <strong>Firmware notes unavailable</strong>
                  <div>Could not load \`device-version-notes.json\`.</div>
                  <div class="muted">Check that the file is served from the site root.</div>
                </div>
              </div>
            `;
            notesArea.classList.remove('hidden');
            return;
          }
          notesArea.classList.add('hidden');
          notesBody.innerHTML = '';
          document.body.classList.remove('composer-notes-visible');
          return;
        }
        const versionLabel = version ? `v${version}` : 'unknown';
        const notesHtml = matching.map(note => `
          <div class="data-item">
            <div>
              <strong>${note.title}</strong>
              <div>${note.body.map(line => `<div>${line}</div>`).join('')}</div>
              <div class="muted">Applies to settings: ${versionLabel}</div>
            </div>
          </div>
        `).join('');
        notesBody.innerHTML = notesHtml;
        notesArea.classList.remove('hidden');
        document.body.classList.add('composer-notes-visible');
      });
    }

    function isCredentialSetting(setting) {
      if (!setting || !setting.id) {
        return false;
      }
      return credentialSettingIds.has(parseInt(setting.id, 16));
    }

    function sanitizeFilename(name) {
      const cleaned = (name || '').toString().trim().replace(/[^A-Za-z0-9_.-]/g, '');
      return cleaned || 'settings.json';
    }

    function ensureJsonExtension(name) {
      if (!name.toLowerCase().endsWith('.json')) {
        return `${name}.json`;
      }
      return name;
    }

    function getProposedFilename() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      const base = selectedFile ? selectedFile.split('/').pop().replace(/\.json$/i, '') : 'settings';
      return `${base}-compose.json`;
    }

    function buildSelectedSettingsPayload() {
      const settings = {};
      const includeCredentials = document.getElementById('composer-export-credentials-toggle')?.checked ?? true;

      if (!settingsData || !settingsData.settings) {
        return settings;
      }

      for (const [key, setting] of Object.entries(settingsData.settings)) {
        const checkbox = document.getElementById(`checkbox-${setting.id}`);
        if (!checkbox || !checkbox.checked) {
          continue; // user didn't select it
        }
        if (!includeCredentials && isCredentialSetting(setting)) {
          continue;
        }

        const value = getInputValue(setting.id);

        if (['uint32', 'uint16', 'uint8', 'int32', 'int8', 'float'].includes(setting.conversion)) {
          settings[key] = Number(value);
        } else if (setting.conversion === 'bool') {
          settings[key] = value === 'true';
        } else {
          settings[key] = value;
        }
      }

      return settings;
    }

    function hasSelectedCommands() {
      if (!settingsData || !settingsData.commands) {
        return false;
      }
      for (const [_, command] of Object.entries(settingsData.commands)) {
        const checkbox = document.getElementById(`checkbox-${command.id}`);
        if (checkbox && checkbox.checked) {
          return true;
        }
      }
      return false;
    }

    function downloadSettingsJson(settings, filename) {
      const json = JSON.stringify(settings, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function exportToJson(filename = 'settings.json') {
      if (hasSelectedCommands()) {
        showToast('Commands cannot be exported. Please deselect commands.');
        return;
      }
      const settings = buildSelectedSettingsPayload();
      if (Object.keys(settings).length === 0) {
        showToast('No settings selected to export');
        return;
      }

      const safeFilename = ensureJsonExtension(sanitizeFilename(filename));
      downloadSettingsJson(settings, safeFilename);
    }

    function updateComposerMessengerMeta() {
      const portEl = document.getElementById('composer-messenger-port');
      if (!portEl) {
        return;
      }
      const port = settingsData && settingsData.ports ? settingsData.ports.port_lr_messaging : null;
      portEl.textContent = `Port: ${Number.isFinite(port) ? port : '-'}`;
    }

    function setComposerMessengerError(message) {
      const errorEl = document.getElementById('composer-messenger-error');
      const outputEl = document.getElementById('composer-messenger-hex');
      if (errorEl) {
        errorEl.textContent = message || '';
      }
      if (!outputEl) {
        return;
      }
      if (message) {
        outputEl.classList.add('invalid');
      } else {
        outputEl.classList.remove('invalid');
      }
    }

    function getComposerMessengerPayload() {
      const input = document.getElementById('composer-messenger-text');
      if (!input) {
        return { empty: true, error: null, payload: null };
      }
      const text = (input.value || '').trim();
      if (!text) {
        return { empty: true, error: null, payload: null };
      }
      const encoder = new TextEncoder();
      const bytes = encoder.encode(text);
      if (bytes.some((b) => b > 0x7F)) {
        return { empty: false, error: 'Only ASCII characters are supported.', payload: null };
      }
      if (bytes.length > COMPOSER_MESSAGING_MAX_LEN) {
        return { empty: false, error: `Message too long (max ${COMPOSER_MESSAGING_MAX_LEN}).`, payload: null };
      }
      const payload = new Uint8Array(1 + bytes.length);
      payload[0] = bytes.length;
      payload.set(bytes, 1);
      return { empty: false, error: null, payload };
    }

    function updateComposerMessengerPayload() {
      const input = document.getElementById('composer-messenger-text');
      const output = document.getElementById('composer-messenger-hex');
      const countEl = document.getElementById('composer-messenger-count');

      if (!input || !output || !countEl) {
        return;
      }

      const text = input.value || '';
      const encoder = new TextEncoder();
      const bytes = encoder.encode(text);

      countEl.textContent = `${bytes.length} / ${COMPOSER_MESSAGING_MAX_LEN}`;
      countEl.style.color = bytes.length > COMPOSER_MESSAGING_MAX_LEN ? '#b42318' : '#7c8797';

      if (!text.trim()) {
        output.value = '(no message)';
        setComposerMessengerError('');
        updateEncodedMessage();
        return;
      }

      if (bytes.some((b) => b > 0x7F)) {
        output.value = '(invalid payload)';
        setComposerMessengerError('Only ASCII characters are supported.');
        updateEncodedMessage();
        return;
      }

      if (bytes.length > COMPOSER_MESSAGING_MAX_LEN) {
        output.value = '(invalid payload)';
        setComposerMessengerError(`Message too long (max ${COMPOSER_MESSAGING_MAX_LEN}).`);
        updateEncodedMessage();
        return;
      }

      const payload = new Uint8Array(1 + bytes.length);
      payload[0] = bytes.length;
      payload.set(bytes, 1);
      output.value = bytesToHex(payload);
      setComposerMessengerError('');
      updateEncodedMessage();
    }

    function showImportPreviewModal({ title, subtitle, rows, note }) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('import-preview-overlay');
        const titleEl = document.getElementById('import-preview-title');
        const subtitleEl = document.getElementById('import-preview-subtitle');
        const noteEl = document.getElementById('import-preview-note');
        const rowsEl = document.getElementById('import-preview-rows');
        const changedOnlyToggle = document.getElementById('import-preview-changed-only');
        const cancelBtn = document.getElementById('import-preview-cancel');
        const confirmBtn = document.getElementById('import-preview-confirm');

        titleEl.textContent = title;
        subtitleEl.textContent = subtitle;
        if (noteEl) {
          noteEl.textContent = note || '';
          noteEl.classList.toggle('hidden', !note);
        }
        function renderRows() {
          const changedOnly = changedOnlyToggle ? changedOnlyToggle.checked : false;
          rowsEl.innerHTML = rows.filter(row => !changedOnly || !row.unchanged).map((row) => `
          <tr class="${row.unchanged ? 'import-preview-unchanged' : ''}">
            <td>
              <div class="import-preview-setting">${row.name}</div>
              <div class="import-preview-meta">${row.key} (${row.id})</div>
              ${row.description ? `<div class="import-preview-desc">${row.description}</div>` : ''}
            </td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">${row.current}</td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">
              ${row.next}
              ${row.unchanged ? '<div class="import-preview-unchanged-tag">unchanged</div>' : ''}
            </td>
          </tr>
          `).join('');
        }
        renderRows();
        if (changedOnlyToggle) {
          changedOnlyToggle.onchange = renderRows;
        }

        function cleanup(result) {
          overlay.classList.add('hidden');
          cancelBtn.removeEventListener('click', onCancel);
          confirmBtn.removeEventListener('click', onConfirm);
          resolve(result);
        }

        function onCancel() {
          cleanup(false);
        }

        function onConfirm() {
          cleanup(true);
        }

        cancelBtn.addEventListener('click', onCancel);
        confirmBtn.addEventListener('click', onConfirm);
        overlay.classList.remove('hidden');
      });
    }

    async function importFromJson() {
      const fileInput = document.getElementById('import-file');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a file to import.');
        return;
      }

      displaySettings();
      console.log('Importing settings from file:', file.name);
      const reader = new FileReader();
      reader.onload = async function (event) {
        try {
          const entries = Object.entries(JSON.parse(event.target.result));
          const previewRows = [];
          const includeCredentials = document.getElementById('composer-import-credentials-toggle')?.checked ?? false;
          const filteredEntries = [];

          for (const [key, value] of entries) {
            const settingObj = getByKey(key);
            if (!settingObj) {
              continue;
            }
            if (!includeCredentials && isCredentialSetting(settingObj)) {
              continue;
            }
            const currentValue = getInputValue(settingObj.id) ?? settingObj.default;
            const unchanged = isSettingValueEqual(key, settingObj, currentValue, value);
            if (!unchanged) {
              filteredEntries.push([key, value]);
            }
            previewRows.push({
              key,
              id: settingObj.id,
              name: settingObj.display_name || key,
              description: getSettingDescription(key),
              current: formatSettingValueForPreview(key, settingObj, currentValue, value, 'current'),
              next: formatSettingValueForPreview(key, settingObj, value, currentValue, 'next'),
              unchanged
            });
          }

          if (previewRows.length === 0) {
            showToast('No valid settings found in the import file.');
            return;
          }
          if (filteredEntries.length === 0) {
            showToast('All selected settings already match the current values.');
            return;
          }

          const ok = await showImportPreviewModal({
            title: `Import ${previewRows.length} settings`,
            subtitle: `File: ${file.name}`,
            rows: previewRows,
            note: includeCredentials ? '' : 'Device credentials will be skipped.'
          });
          if (!ok) {
            showToast('Import cancelled');
            return;
          }

          for (const [key, value] of filteredEntries) {
            const settingObj = getByKey(key);
            if (settingObj) {
              const checkbox = document.getElementById(`checkbox-${settingObj.id}`);
              checkbox.checked = true;
              checkbox.parentElement.parentElement.classList.remove('transparent');
              setInputValue(settingObj.id, value);
            }
          }
        } catch (error) {
          console.error('Error importing settings:', error);
          showToast('Failed to import settings. Please check the file format.');
        }
      };
      reader.readAsText(file);
    }

    function displaySettings() {
      const settingsSection = document.getElementById('settings-section');
      settingsSection.innerHTML = '';

      const groupedSettings = groupAndSortSettings(settingsData.settings);

      for (const [groupName, group] of Object.entries(groupedSettings)) {
        const groupWrapper = document.createElement('div');
        groupWrapper.className = 'settings-group is-collapsed';

        const groupToggle = document.createElement('button');
        groupToggle.type = 'button';
        groupToggle.className = 'group-toggle';
        groupToggle.setAttribute('aria-expanded', 'false');
        groupToggle.innerHTML = `
          <span class="group-title">${groupName.replace(/_/g, " ")}</span>
          <span class="group-caret" aria-hidden="true"></span>
        `;
        groupToggle.addEventListener('click', () => toggleGroup(groupWrapper));

        const settingsContainer = document.createElement('div');
        settingsContainer.className = 'settings-container';

        for (const [key, setting] of Object.entries(group)) {
          // Create the top-level container
          const row = document.createElement('div');
          row.className = 'setting transparent';
          row.setAttribute('id', `setting-${setting.id}`);
          const settingDescription = getSettingDescription(key);
          row.setAttribute('data-search', `${key} ${setting.display_name} ${settingDescription}`.trim());

          // Build the "include" checkbox + label
          row.innerHTML = `
            <div class="checkbox-container">
              <input type="checkbox" id="checkbox-${setting.id}" onchange="updateCheckBox(this, '${setting.id}')"/>
              <label for="checkbox-${setting.id}"><h4 title="${key}">${setting.display_name} <small>${key} (${setting.id})</small></h4></label>
            </div>${renderInputContainer(key, setting)}
            ${settingDescription ? `<p class="setting-help">${settingDescription}</p>` : ""}
          `;

          settingsContainer.appendChild(row);
        }

        groupWrapper.appendChild(groupToggle);
        groupWrapper.appendChild(settingsContainer);
        settingsSection.appendChild(groupWrapper);
      }
    }

    function displayCommands() {
      const commandsSection = document.getElementById('commands-section');
      commandsSection.innerHTML = '';

      function getKnownPortOptions() {
        const options = [{ label: 'all ports', value: 0 }];
        const ports = settingsData && settingsData.ports ? settingsData.ports : null;
        if (ports) {
          Object.entries(ports)
            .filter(([_, portNum]) => Number.isFinite(portNum))
            .map(([portName, portNum]) => ({
              label: portName.replace(/^port_/, ''),
              value: portNum
            }))
            .sort((a, b) => a.value - b.value)
            .forEach(option => options.push(option));
        }
        return options
          .map(option => `<option value="${option.value}">${option.label} (port ${option.value})</option>`)
          .join('');
      }

      for (const [key, command] of Object.entries(settingsData.commands)) {
        if (dangerousCommands.some(rx => rx.test(key))) {
          continue;
        }

        // Create the top-level container
        const row = document.createElement('div');
        row.className = 'setting transparent';
        row.setAttribute('id', `setting-${command.id}`);

        // Build the "include" checkbox + label
        const commandLabel = getCommandLabel(key);
        const commandDescription = getCommandDescription(key);
        const commandInputMeta = getCommandInputMeta(key);
        let helperHtml = '';
        if (commandInputMeta && commandInputMeta.source === 'values') {
          const valueOptions = getCommandValueOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Value</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${valueOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        } else if (commandInputMeta && commandInputMeta.source === 'settings') {
          const settingOptions = getCommandSettingOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Setting</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${settingOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        } else if (key === 'cmd_flash_get_from_head') {
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}-port">Port</label>
            <select id="command-select-${command.id}-port" class="command-helper-input">
              ${getKnownPortOptions()}
            </select>
            <label class="command-helper-label" for="command-input-${command.id}-start">Start</label>
            <input id="command-input-${command.id}-start" class="command-helper-input" type="text" placeholder="50" data-format="uint32" />
            <label class="command-helper-label" for="command-input-${command.id}-count">How many</label>
            <input id="command-input-${command.id}-count" class="command-helper-input" type="text" placeholder="10" data-format="uint32" />
          `;
        } else if (commandInputMeta && commandInputMeta.options) {
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Value</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${commandInputMeta.options.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
            </select>
          `;
        } else if (commandInputMeta && commandInputMeta.input) {
          const placeholder = commandInputMeta.input.placeholder || '';
          const labelText = commandInputMeta.input.label || 'Value';
          const dataFormat = commandInputMeta.input.format || 'uint8';
          helperHtml = `
            <label class="command-helper-label" for="command-input-${command.id}">${labelText}</label>
            <input id="command-input-${command.id}" class="command-helper-input" type="text" placeholder="${placeholder}" data-format="${dataFormat}" />
          `;
        }
        row.innerHTML = `
          <div class="checkbox-container">
            <input type="checkbox" id="checkbox-${command.id}" onchange="updateCheckBox(this, '${command.id}')"/>
            <label for="checkbox-${command.id}"><h4>${commandLabel} <small>${key} (${command.id})</small></h4></label>
          </div>${helperHtml ? `<div class="command-helper hidden" id="command-helper-${command.id}">${helperHtml}</div>` : ''}
          ${commandDescription ? `<p class="setting-help">${commandDescription}</p>` : ""}
        `;

        commandsSection.appendChild(row);
      }
    }

    function onInputChanged(setting, value, valid) {
      updateEncodedMessage();
    }

    function updateCheckBox(element, id) {
      if (element.checked) {
        element.parentElement.parentElement.classList.remove('transparent');
        setDefaultValue(id);
        const helper = document.getElementById(`command-helper-${id}`);
        if (helper) {
          helper.classList.remove('hidden');
        }
      } else {
        clearInputValue(id);
        element.parentElement.parentElement.classList.add('transparent');
        const helper = document.getElementById(`command-helper-${id}`);
        if (helper) {
          helper.classList.add('hidden');
          const selectEl = helper.querySelector('select');
          if (selectEl) {
            selectEl.selectedIndex = 0;
          }
          const inputEl = helper.querySelector('input');
          if (inputEl) {
            inputEl.value = '';
          }
        }
      }
      updateEncodedMessage();
    }

    const payloadIconPaths = {
      copy: {
        viewBox: '0 0 512 576',
        path: 'M224 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l160 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64L224 0zM64 128l64 0 0 64-64 0c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l192 0c17.7 0 32-14.3 32-32l0-64 64 0 0 64c0 53-43 96-96 96L64 576c-53 0-96-43-96-96l0-256c0-53 43-96 96-96z'
      },
      download: {
        viewBox: '0 0 512 512',
        path: 'M256 0c17.7 0 32 14.3 32 32l0 246.1 73.4-73.4c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3l-128 128c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l73.4 73.4L224 32c0-17.7 14.3-32 32-32zM64 416c0-17.7 14.3-32 32-32l320 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32z'
      }
    };

    function setPayloadIcon(mode) {
      const icon = document.getElementById('payload-icon');
      if (!icon || !payloadIconPaths[mode]) {
        return;
      }
      icon.setAttribute('viewBox', payloadIconPaths[mode].viewBox);
      icon.innerHTML = `<path d="${payloadIconPaths[mode].path}"></path>`;
    }

    // ---------------------------------------------
    // Build final payload
    // ---------------------------------------------
    function updateEncodedMessage() {
      const hexOutput = document.getElementById('hex-output');
      const payloadType = document.getElementById('payload-type');
      const actionButton = document.getElementById('copy-button');
      document.getElementById('payload-lorawan').innerHTML = `LoRaWAN`;

      const payloadValue = payloadType ? payloadType.value : 'none';

      if (payloadType == null || payloadValue === 'none') {
        hexOutput.value = '(please select a payload type)';
        hexOutput.readOnly = true;
        setPayloadIcon('copy');
        lastPayloadType = 'none';
        return;
      }

      if (payloadValue === 'file_export') {
        if (hasSelectedCommands()) {
          hexOutput.value = 'Error: Commands cannot be exported';
          hexOutput.classList.add('invalid');
          setPayloadIcon('copy');
          lastPayloadType = 'file_export';
          return;
        }
        const selectedSettings = buildSelectedSettingsPayload();
        const hasSelectedSettings = Object.keys(selectedSettings).length > 0;
        hexOutput.classList.remove('invalid');
        hexOutput.readOnly = false;
        setPayloadIcon('download');

        if (hasSelectedSettings) {
          if (lastPayloadType !== 'file_export' || hexOutput.value === '(no settings selected)') {
            hexOutput.value = getProposedFilename();
          } else if (!hexOutput.value.trim()) {
            hexOutput.value = getProposedFilename();
          }
        } else {
          hexOutput.value = '(no settings selected)';
        }

        lastPayloadType = 'file_export';
        return;
      }

      hexOutput.readOnly = true;
      setPayloadIcon('copy');
      lastPayloadType = payloadValue;

      const encodedBytes = [];
      hexOutput.classList.remove('invalid');
      const messengerPayload = getComposerMessengerPayload();

      const types = new Set();
      // Iterate each known setting
      for (const [intId, val] of settingsMap) {
        const [settingKey, settingObj] = val;

        // The top-level "include" checkbox
        const checkbox = document.getElementById(`checkbox-${settingObj.id}`);
        if (!checkbox || !checkbox.checked) {
          continue; // user didn't select it
        }

        types.add(settingObj.type);

        if (types.size > 1) {
          hexOutput.value = 'Error: Cannot mix different types';
          hexOutput.classList.add('invalid');
          return;
        }

        // Convert to bytes
        let valueBytes;
        try {
          if (settingObj.type === 'command' && settingObj.length === 1) {
            const selectEl = document.getElementById(`command-select-${settingObj.id}`);
            const inputEl = document.getElementById(`command-input-${settingObj.id}`);
            let value = 0;
            if (selectEl) {
              const selected = selectEl.value;
              value = selected && selected.startsWith('0x') ? parseInt(selected, 16) : parseInt(selected, 10);
            } else if (inputEl) {
              const rawValue = inputEl.value.trim();
              const format = inputEl.getAttribute('data-format') || 'uint8';
              if (rawValue.length === 0) {
                value = 0;
              } else if (format === 'hex8') {
                const cleaned = rawValue.replace(/^0x/i, '');
                const parsed = parseInt(cleaned, 16);
                if (Number.isNaN(parsed)) {
                  throw new Error('Invalid hex value');
                }
                value = parsed;
              } else {
                const parsed = parseInt(rawValue, 10);
                if (Number.isNaN(parsed)) {
                  throw new Error('Invalid numeric value');
                }
                value = parsed;
              }
            } else if (settingObj.value !== undefined) {
              value = settingObj.value;
            }
            valueBytes = settingToBytes(settingKey, settingObj, value.toString());
          } else if (settingObj.type === 'command' && settingKey === 'cmd_flash_get_from_head') {
            const portEl = document.getElementById(`command-select-${settingObj.id}-port`);
            const startEl = document.getElementById(`command-input-${settingObj.id}-start`);
            const countEl = document.getElementById(`command-input-${settingObj.id}-count`);
            const parseUint32 = (el, label) => {
              if (!el) {
                return 0;
              }
              const rawValue = el.value.trim();
              if (!rawValue) {
                return 0;
              }
              const parsed = rawValue.startsWith('0x') ? parseInt(rawValue, 16) : parseInt(rawValue, 10);
              if (!Number.isFinite(parsed) || parsed < 0 || parsed > 0xFFFFFFFF) {
                throw new Error(`Invalid ${label} (uint32)`);
              }
              return parsed >>> 0;
            };
            const port = parseUint32(portEl, 'port');
            const start = parseUint32(startEl, 'start index');
            const count = parseUint32(countEl, 'count');
            const payload = new Uint8Array(12);
            const view = new DataView(payload.buffer);
            view.setUint32(0, port, true);
            view.setUint32(4, start, true);
            view.setUint32(8, count, true);
            valueBytes = payload;
          } else {
            valueBytes = settingToBytes(settingKey, settingObj, getInputValue(settingObj.id));
          }
        } catch (error) {
          hexOutput.value = `Error (${settingKey}): ${error.message}`;
          hexOutput.classList.add('invalid');
          return;
        }

        // Example format: [settingId, length, valueBytes...]
        const length = valueBytes.length;
        const idInt = parseInt(settingObj.id, 16);

        encodedBytes.push(idInt, length, ...valueBytes);
      }

      // If nothing is selected
      if (encodedBytes.length === 0) {
        if (!messengerPayload.empty) {
          if (messengerPayload.error) {
            hexOutput.value = `Error (messenger): ${messengerPayload.error}`;
            hexOutput.classList.add('invalid');
            return;
          }
          encodedBytes.push(...messengerPayload.payload);
          types.add('messenger');
        } else {
          hexOutput.value = '(no settings selected)';
          return;
        }
      } else if (!messengerPayload.empty) {
        hexOutput.value = 'Error: Messenger payload cannot be combined with settings or commands';
        hexOutput.classList.add('invalid');
        return;
      }

      let port = 0;
      if (types.has("setting")) {
        port = 3;
      } else if (types.has("command")) {
        port = 32;
      } else if (types.has("messenger")) {
        port = settingsData && settingsData.ports ? settingsData.ports.port_lr_messaging : null;
        if (!Number.isFinite(port)) {
          hexOutput.value = 'Error: No LoRaWAN messaging port found';
          hexOutput.classList.add('invalid');
          return;
        }
      } else {
        hexOutput.value = 'Error: Unknown type ' + types;
        hexOutput.classList.add('invalid');
        return;
      }

      // Depending on payloadType
      if (payloadType.value === 'lorawan') {
        hexOutput.value = bytesToHex(encodedBytes);
        document.getElementById('payload-lorawan').innerHTML = `LoRaWAN (port: ${port})`;
      } else if (payloadType.value === 'rockblock') {
        encodedBytes.unshift(port);
        hexOutput.value = bytesToHex(encodedBytes);
      } else if (payloadType.value === 'ble') {
        encodedBytes.unshift(port);
        hexOutput.value = encodedBytes.map(b => '0x' + toHex(b)).join(' ');
      }
    }

    // Copy to clipboard
    function copyToClipboard() {
      updateEncodedMessage();
      const payloadType = document.getElementById('payload-type');
      if (payloadType && payloadType.value === 'file_export') {
        const filenameInput = document.getElementById('hex-output').value;
        const filename = ensureJsonExtension(sanitizeFilename(filenameInput || getProposedFilename()));
        exportToJson(filename);
        return;
      }
      const hexOutput = document.getElementById('hex-output');
      navigator.clipboard.writeText(hexOutput.value).then(() => {
        showToast('Copied to clipboard');
      }).catch(err => {
        showToast('Failed to copy to clipboard');
        console.error('Could not copy text: ', err);
      });
    }

    populateSettingsIntoPage();

    // Load first file on page load
    loadSelectedFile();
  </script>
</body>

</html>
