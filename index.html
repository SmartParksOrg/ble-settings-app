<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenCollar Edge BLE Web Connect</title>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(reg => console.log('Service Worker registered:', reg))
        .catch(err => console.error('Service Worker registration failed:', err));
    }
  </script>
  <link rel="stylesheet" href="style.css" />
  <link rel="manifest" href="manifest.json">
  <script src="functions.js"></script>
</head>

<body>
  <div id="header-section" class="page-section">
    <div class="brand">
      <img src="assets/smart-parks-logo.png" alt="Smart Parks" class="brand-logo" />
      <div class="brand-title">
        <span class="brand-name">Smart Parks</span>
        <span class="brand-subtitle">OpenCollar Edge BLE Web Connect</span>
      </div>
    </div>
    <div class="controls">
      <div style="display: flex; justify-content: space-between;">
        <button id="disconnect-button" class="hidden-when-disconnected">Disconnect</button>
        <div class="button-cluster">
          <div class="hidden-when-no-settings">
            <input type="file" id="import-file" onchange="importFromJson()" style="display: none;" />
          </div>
          <button id="dfu-button" class="hidden-when-disconnected dfu-hide scan-button" onclick="openDfuPage()">DFU</button>
          <button id="dfu-back-top" class="secondary dfu-only">Back</button>
        </div>
      </div>
      <div class="hidden-when-connected">
        <section class="section section-card scan-card">
          <div class="section-card-title"><span class="icon ble-scan" aria-hidden="true"></span>Scan</div>
          <div class="section-card-body">
            <div class="primary-actions">
              <button id="connect-button" class="scan-button">Scan</button>
            </div>
            <details class="section section-card scan-settings-card">
              <summary class="section-card-title"><span class="icon ble-scan" aria-hidden="true"></span>Scan settings</summary>
              <div class="section-card-body">
                <label class="scan-settings-label" for="device-name-filter">
                  Device name filter (comma-separated prefixes):
                  <input
                    id="device-name-filter"
                    type="text"
                    class="scan-filter-input"
                    placeholder="e.g. SP05, SP06"
                    autocomplete="off"
                    spellcheck="false"
                  />
                </label>
                <label class="scan-settings-label pin-row" id="pin-label">
                  Device PIN:
                  <input
                    name="pincode"
                    id="pincode"
                    type="text"
                    class="pincode"
                    value="0000"
                    inputmode="numeric"
                    maxlength="4"
                  />
                </label>
              </div>
            </details>
          </div>
        </section>
        <section class="section section-card composer-card">
          <div class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Composer</div>
          <div class="section-card-body">
            <div class="composer-actions">
              <a class="button composer-button" href="composer.html">Composer</a>
            </div>
          </div>
        </section>
      </div>
      <div id="settings-selection" class="hidden-when-disconnected">
        <select id="settings-dropdown" onchange="loadSelectedSettings()"></select>
      </div>
      <div id="container"></div>

      <div id="dfu-container" class="hidden">
        <div id="dfu-connection-status" class="dfu-connection-status">Not connected</div>
      </div>
    </div>
  </div>

  <div id="status-area" class="status-section page-section hidden-when-no-status">
    <details class="section section-card" open>
      <summary class="section-card-title"><span class="icon square-poll-horizontal" aria-hidden="true"></span>Status</summary>
      <div class="section-card-body" id="status-message"></div>
    </details>
  </div>

  <div id="actions-area" class="commands-section page-section hidden-when-no-settings">
    <details class="section section-card" open>
      <summary class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Actions</summary>
      <div class="section-card-body">
        <div id="main-commands"></div>
      </div>
    </details>
  </div>

  <div id="logs-area" class="commands-section page-section hidden-when-no-settings">
    <details class="section section-card" open>
      <summary class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Logs</summary>
      <div class="section-card-body">
        <div class="status-header">
          <div class="status-item"><span class="icon messages"></span>Flash log</div>
          <a href="#" onclick="requestFlashLogCount()">
            <div class="status-item"><span class="icon refresh"></span>refresh</div>
          </a>
        </div>
        <div class="data-item">
          <span>Flash messages</span>
          <span id="flash-log-count">Not loaded</span>
        </div>
        <div class="data-item">
          <span>Status</span>
          <span id="flash-log-status">Waiting for settings...</span>
        </div>
        <div class="log-actions">
          <button type="button" class="log-action-button" onclick="executeCommand(settingsData?.commands?.cmd_flash_get_all?.id)">Download all logs</button>
        </div>
        <div class="log-actions">
          <select id="flash-log-type-select" class="log-type-select" aria-label="Flash log message type">
            <option value="">Load settings to choose a message type</option>
          </select>
          <button type="button" class="log-action-button" onclick="downloadFlashLogsByType()">Download selected message type</button>
        </div>
        <div class="log-actions">
          <button type="button" class="log-action-button secondary" onclick="requestEraseAllLogs()">Erase all logs</button>
        </div>
      </div>
    </details>
  </div>

  <div id="settings-area" class="settings-section page-section hidden-when-no-settings">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon hw-version" aria-hidden="true"></span>Settings</summary>
      <div class="section-card-body">
        <div class="settings-options">
          <button id="import-button" class="section-action" onclick="document.getElementById('import-file').click();">Import settings</button>
          <button id="export-button" class="section-action" onclick="exportToJson()">Export settings</button>
          <label class="settings-option">
            <input type="checkbox" id="import-credentials-toggle">
            Include device credentials on import
          </label>
          <label class="settings-option">
            <input type="checkbox" id="export-credentials-toggle" checked>
            Include device credentials on export
          </label>
        </div>
        <div id="search" class="search">
          <input type="text" id="settings-search" placeholder="Search settings..." oninput="filterSettings()">
          <label>
            <input type="checkbox" id="non-default-checkbox" onchange="filterSettings()"> Hide default settings
          </label>
        </div>
        <div id="settings-progress">
          <div></div>
        </div>
        <div id="settings-section"></div>
      </div>
    </details>
  </div>

  <div id="other-commands" class="commands-section page-section hidden-when-no-settings">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Commands</summary>
      <div class="section-card-body">
        <div id="commands-buttons-section"></div>
      </div>
    </details>
  </div>

  <div id="map-area" class="map-section page-section hidden-when-no-status">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon ublox-location" aria-hidden="true"></span>Map</summary>
      <div class="section-card-body">
        <div id="map-status" class="map-status">Waiting for location...</div>
        <div class="map-frame">
          <button id="map-view-toggle" class="map-view-toggle" type="button" onclick="toggleMapFullscreen()" aria-label="Toggle fullscreen map" title="Fullscreen map">Fullscreen</button>
          <div id="device-map" class="map-canvas"></div>
          <div id="map-overlay" class="map-overlay hidden">Offline: map unavailable</div>
        </div>
        <div class="log-actions">
          <button type="button" class="log-action-button" onclick="getTracks()">Get tracks</button>
        </div>
      </div>
    </details>
  </div>

  <nav class="bottom-nav hidden-when-disconnected dfu-keep-visible" aria-label="Primary">
    <a href="#header-section" class="nav-logo" aria-label="Smart Parks">
      <img src="assets/smart-parks-logo.png" alt="Smart Parks" />
    </a>
    <button type="button" class="dfu-only dfu-only-nav" onclick="toggleDfuView(false)" aria-label="Home" title="Home"><span class="icon house" aria-hidden="true"></span></button>
    <a href="#status-area" class="dfu-hide-nav" aria-label="Status" title="Status"><span class="icon square-poll-horizontal" aria-hidden="true"></span></a>
    <a href="#settings-area" class="dfu-hide-nav lr-update-hide" aria-label="Settings" title="Settings"><span class="icon hw-version" aria-hidden="true"></span></a>
    <a href="#other-commands" class="dfu-hide-nav lr-update-hide" aria-label="Commands" title="Commands"><span class="icon messages" aria-hidden="true"></span></a>
    <a href="#map-area" class="dfu-hide-nav lr-update-hide" aria-label="Map" title="Map"><span class="icon ublox-location" aria-hidden="true"></span></a>
    <button type="button" onclick="toggleLog()" aria-label="Log" title="Log"><span class="icon toggle-log" aria-hidden="true"></span></button>
  </nav>

  <div class="log-footer hidden-when-disconnected dfu-keep-visible" id="logFooter">
    <div class="log-header" onclick="toggleLog()">
      <span>Log</span>
      <span class="icon close"></span>
    </div>
    <div class="log-content" id="log"></div>
  </div>

  <div id="import-preview-overlay" class="import-preview-overlay hidden" role="dialog" aria-modal="true"
    aria-labelledby="import-preview-title">
    <div class="import-preview-dialog">
      <div class="import-preview-header">
        <h3 id="import-preview-title">Import preview</h3>
        <p id="import-preview-subtitle"></p>
        <p id="import-preview-note" class="import-preview-note hidden"></p>
      </div>
      <div class="import-preview-body">
        <label class="import-preview-toggle">
          <input type="checkbox" id="import-preview-changed-only" checked>
          Show changed only
        </label>
        <div id="import-preview-progress" class="import-preview-progress hidden">
          <div id="import-preview-progress-text" class="import-preview-progress-text"></div>
          <div class="import-preview-progress-bar">
            <div id="import-preview-progress-bar"></div>
          </div>
        </div>
        <table class="import-preview-table">
          <thead>
            <tr>
              <th>Setting</th>
              <th>Current</th>
              <th>New</th>
            </tr>
          </thead>
          <tbody id="import-preview-rows"></tbody>
        </table>
      </div>
      <div class="import-preview-footer">
        <button id="import-preview-cancel" class="secondary" type="button">Cancel</button>
        <button id="import-preview-confirm" type="button">Import</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <div id="map-tracks-overlay" class="dfu-waiting-overlay hidden" role="dialog" aria-modal="true">
    <div class="dfu-waiting-card">
      <div id="map-tracks-spinner" class="dfu-spinner hidden"></div>
      <div id="map-tracks-title" class="dfu-waiting-text">Tracks</div>
      <div id="map-tracks-text" class="dfu-waiting-countdown"></div>
      <div class="ublox-fix-actions">
        <button id="map-tracks-ok" type="button" class="primary">OK</button>
      </div>
    </div>
  </div>

  <div id="flash-log-overlay" class="dfu-waiting-overlay hidden" role="dialog" aria-modal="true">
    <div class="dfu-waiting-card flash-log-card">
      <div id="flash-log-overlay-spinner" class="dfu-spinner"></div>
      <div id="flash-log-overlay-title" class="dfu-waiting-text">Downloading logs...</div>
      <div id="flash-log-overlay-progress-text" class="dfu-progress-text">Preparing download...</div>
      <div id="flash-log-overlay-progress" class="flash-log-progress">
        <div id="flash-log-overlay-progress-bar"></div>
      </div>
      <div id="flash-log-overlay-message" class="flash-log-overlay-message hidden"></div>
      <div class="ublox-fix-actions">
        <button id="flash-log-retry" type="button" class="primary hidden">Retry</button>
        <button id="flash-log-cancel" type="button" class="secondary">Cancel</button>
        <button id="flash-log-erase" type="button" class="secondary hidden">Erase all logs</button>
        <button id="flash-log-ok" type="button" class="primary hidden">OK</button>
      </div>
    </div>
  </div>

  <div id="flash-log-erase-confirm-overlay" class="dfu-waiting-overlay hidden" role="dialog" aria-modal="true">
    <div class="dfu-waiting-card">
      <div class="dfu-waiting-text">Warning: this will permanently erase all logs from device flash.</div>
      <div class="dfu-confirmation-actions">
        <button id="flash-log-erase-cancel" class="secondary" type="button">Cancel</button>
        <button id="flash-log-erase-confirm" type="button">Erase all logs</button>
      </div>
    </div>
  </div>

  <div id="ublox-fix-overlay" class="dfu-waiting-overlay hidden" role="dialog" aria-modal="true">
    <div class="dfu-waiting-card ublox-fix-card">
      <div id="ublox-fix-spinner" class="dfu-spinner"></div>
      <div id="ublox-fix-title" class="dfu-waiting-text">Waiting for UBLOX fix...</div>
      <div id="ublox-fix-results" class="ublox-fix-results hidden"></div>
      <div id="ublox-fix-map" class="ublox-fix-map hidden"></div>
      <div id="ublox-fix-raw" class="ublox-fix-raw hidden"></div>
      <div class="ublox-fix-actions">
        <button id="ublox-fix-retry" type="button" class="primary hidden">Retry</button>
        <button id="ublox-fix-cancel" type="button" class="secondary hidden">Cancel</button>
        <button id="ublox-fix-ok" type="button" class="primary hidden">OK</button>
      </div>
    </div>
  </div>

  <div id="dfu-warning-overlay" class="dfu-waiting-overlay hidden">
    <div class="dfu-waiting-card">
      <div class="dfu-waiting-text">Warning: The DFU feature is still in development and should not be used.</div>
      <div class="dfu-confirmation-actions">
        <button id="dfu-warning-cancel" class="secondary" type="button">Cancel</button>
        <button id="dfu-warning-proceed" type="button">Proceed</button>
      </div>
    </div>
  </div>

  <div id="dfu-section" class="page-section hidden">
    <div id="dfu-waiting-overlay" class="dfu-waiting-overlay hidden">
      <div class="dfu-waiting-card">
        <div id="dfu-waiting-spinner" class="dfu-spinner"></div>
        <div id="dfu-waiting-text" class="dfu-waiting-text">Device is rebooting. Reconnect will be enabled shortly.</div>
        <div id="dfu-waiting-countdown" class="dfu-waiting-countdown"></div>
        <button id="dfu-waiting-scan" type="button" class="primary" disabled>Scan and Reconnect</button>
        <button id="dfu-waiting-continue" type="button" class="primary hidden">Go to device</button>
      </div>
    </div>
    <section class="section section-card dfu-card">
      <div class="section-card-title"><span class="icon hw-version" aria-hidden="true"></span>Connected device</div>
      <div class="section-card-body">
        <div class="dfu-device-grid">
          <div>
            <div class="dfu-label">Device</div>
            <div id="dfu-device-name" class="dfu-value">Unknown</div>
          </div>
          <div>
            <div class="dfu-label">Hardware</div>
            <div id="dfu-device-hw" class="dfu-value">Unknown</div>
          </div>
          <div>
            <div class="dfu-label">Firmware</div>
            <div id="dfu-device-fw" class="dfu-value">Unknown</div>
          </div>
          <div>
            <div class="dfu-label">Last status</div>
            <div id="dfu-device-updated" class="dfu-value">Not available</div>
          </div>
        </div>
        <div id="dfu-device-warning" class="dfu-warning hidden">
          Device details are missing. Connect to a device and wait for the status to load.
        </div>
      </div>
    </section>

    <section class="section section-card dfu-card">
      <div class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Step 1: Select DFU file</div>
      <div class="section-card-body">
        <div class="dfu-file-picker">
          <input type="file" id="dfu-file" class="dfu-file-input" accept=".bin,.zip" />
          <label for="dfu-file" class="button dfu-file-button">Select DFU file</label>
          <div class="dfu-file-hint">.bin or .zip</div>
        </div>
        <div id="dfu-file-status" class="dfu-file-status">No file selected.</div>
        <div id="dfu-check-status" class="dfu-check-status">Waiting for file selection.</div>
        <div id="dfu-file-match" class="dfu-file-match hidden"></div>
        <div id="dfu-confirmation" class="dfu-confirmation hidden">
          <div class="dfu-confirmation-text">File checked. Do you want to continue with DFU?</div>
          <div class="dfu-confirmation-actions">
            <button id="dfu-confirm-cancel" class="secondary" type="button">Cancel</button>
            <button id="dfu-confirm-proceed" type="button">Proceed</button>
          </div>
        </div>
      </div>
    </section>

    <section class="section section-card dfu-card hidden" id="dfu-upload-section">
      <div class="section-card-title"><span class="icon ble-scan" aria-hidden="true"></span>Step 2: Upload firmware</div>
      <div class="section-card-body">
        <div class="dfu-upload-status">
          <div class="dfu-upload-status-title">Upload status</div>
          <ul class="dfu-upload-status-list" id="dfu-upload-status-list">
            <li data-step="file"><span class="status-label">File selected</span><span class="status-detail"></span></li>
            <li data-step="start"><span class="status-label">Upload started</span><span class="status-detail"></span></li>
            <li data-step="ack"><span class="status-label">Chunk acknowledged</span><span class="status-detail"></span></li>
            <li data-step="finish"><span class="status-label">Upload finished</span><span class="status-detail"></span></li>
            <li data-step="state"><span class="status-label">Image state checked</span><span class="status-detail"></span></li>
            <li data-step="test"><span class="status-label">Marked for test</span><span class="status-detail"></span></li>
            <li data-step="reboot"><span class="status-label">Device rebooted</span><span class="status-detail"></span></li>
            <li data-step="reconnect"><span class="status-label">Reconnected</span><span class="status-detail"></span></li>
            <li data-step="verify"><span class="status-label">Verified active</span><span class="status-detail"></span></li>
            <li data-step="confirm"><span class="status-label">Confirmed</span><span class="status-detail"></span></li>
          </ul>
        </div>
        <div class="dfu-upload-actions">
          <button id="dfu-upload" disabled>Start DFU upload</button>
          <button id="dfu-cancel" class="secondary" disabled>Cancel</button>
          <button id="dfu-finish" class="secondary">Finish DFU</button>
        </div>
        <div class="dfu-upload-settings">
          <label class="dfu-upload-setting">
            MTU budget (bytes)
            <input id="dfu-upload-mtu" type="number" min="80" step="8" value="240" />
          </label>
          <label class="dfu-upload-setting">
            Chunk timeout (ms)
            <input id="dfu-upload-timeout" type="number" min="1000" step="500" value="5000" />
          </label>
        </div>
        <div class="dfu-progress">
          <div class="dfu-progress-bar" id="dfu-progress-bar"></div>
        </div>
        <div id="dfu-progress-text" class="dfu-progress-text">Upload progress: 0%</div>
      </div>
    </section>

    <details class="section section-card dfu-card dfu-advanced-card" id="dfu-advanced-card">
      <summary class="section-card-title"><span class="icon settings" aria-hidden="true"></span>Advanced tools</summary>
      <div class="section-card-body">
        <div class="dfu-upload-actions">
          <button id="dfu-refresh-state" class="secondary">Refresh image state</button>
          <button id="dfu-test-image" class="secondary">Test uploaded image</button>
          <button id="dfu-confirm-image" class="secondary">Confirm active image</button>
          <button id="dfu-reset-session" class="secondary">Reset DFU session</button>
        </div>
        <div class="dfu-image-state" id="dfu-image-state">
          <div class="dfu-image-state-title">Image slots</div>
          <div class="dfu-image-state-list" id="dfu-image-state-list">
            <div class="dfu-image-state-empty">No image state loaded.</div>
          </div>
        </div>
      </div>
    </details>
  </div>

  <footer class="app-version-footer">
    <span class="app-version" id="app-version">Version: loading...</span>
  </footer>

  <script>
    const CMD_SINGLE_SETTING = 0xA8;
    const CMD_SINGLE_VALUE = 0xA3;
    const CMD_STATUS = 0xA4;
    const CMD_SEND_ALL_SETTINGS = 0xA7;
    const CMD_SET_LOCATION_AND_TIME = 0xAF;
    const CMD_SEND_POSITION = 0xA5;
    const CMD_CHECK_PIN = 0xC2;
    const CMD_SEND_SINGLE_VAL = 0xA3;
    const CMD_SEND_TIMESTAMP = 0xCE;
    const CMD_FLASH_CLEAR = 0xBA;
    const CMD_FLASH_GET_FROM_HEAD = 0xBC;
    const TRACK_POINTS_LIMIT = 25;
    const VAL_UBLOX_TIME = 0xD8;
    const MSG_TIMESTAMP = 0x97;
    const MSG_CMD_CONFIRM = 0xF3;
    const MSG_LAST_POSITION = 0xFE;
    const LR_UPDATE_FW_MAJOR = 5;
    const LR_UPDATE_FW_MINOR = 0;

    const excludeFromImportExport = ['tracker_type', 'ble_adv'];
    const credentialSettingIds = new Set([0x10, 0x11, 0x12, 0x21, 0x2a, 0x44, 0x45, 0x46]);
    const mainCommands = {
      'cmd_join': 'Join LP1',
      'cmd_send_status_lr': 'Send status to LR1',
      'cmd_get_ublox_fix': 'Get UBLOX fix',
      'cmd_reset': 'Reboot device',
    };

    let device, server, txCharacteristic, rxCharacteristic;
    window.device = device;
    window.server = server;
    window.txCharacteristic = txCharacteristic;
    window.rxCharacteristic = rxCharacteristic;
    let readAllSettings = null;
    let autoLoaded = false;
    let lastPositionMessage = null;
    let mapInstance = null;
    let mapMarker = null;
    let mapTrackLayer = null;
    let mapTrackLatestMarker = null;
    let mapReady = false;
    let mapFullscreen = false;
    let leafletPromise = null;
    let userRequestedDisconnect = false;
    let lrUpdateMode = false;
    let ubloxFixPending = false;
    let ubloxFixTimeoutId = null;
    let ubloxFixCountdownId = null;
    let ubloxBusyStatus = false;
    let ubloxFixMapInstance = null;
    let ubloxFixMapMarker = null;
    let mapTrackState = {
      active: false,
      phase: null,
      points: [],
      pendingPlans: [],
      flashBuffer: new Uint8Array(0),
    };
    let flashLogState = {
      active: false,
      lines: [],
      buffer: '',
      startedAt: null,
      deviceName: '',
      logTypeLabel: 'all',
      requestMode: 'all',
      requestedPort: 0,
      expectedTotal: null,
      inactivityTimeoutId: null,
      lastFilename: '',
      lastError: '',
      lastRequest: null
    };
    let flashLogCountTotal = null;

    const logFooter = document.getElementById('logFooter');

    function toggleLog() {
      const basePadding = getComputedStyle(document.documentElement).getPropertyValue('--body-bottom-padding').trim() || '50px';
      logFooter.classList.toggle('open');
      document.body.style.paddingBottom = logFooter.classList.contains('open') ? logFooter.clientHeight + "px" : basePadding;
      const logElement = document.getElementById('log');
      logElement.scrollTop = logElement.scrollHeight;
    }
    window.toggleLog = toggleLog;

    function isLrUpdateFirmware(statusMessage) {
      return statusMessage
        && statusMessage.ver_fw_major === LR_UPDATE_FW_MAJOR
        && statusMessage.ver_fw_minor === LR_UPDATE_FW_MINOR;
    }

    function isCredentialSetting(setting) {
      if (!setting || !setting.id) {
        return false;
      }
      return credentialSettingIds.has(parseInt(setting.id, 16));
    }

    function setLrUpdateMode(enabled) {
      lrUpdateMode = Boolean(enabled);
      document.body.classList.toggle('lr-update', lrUpdateMode);
    }

    function loadLeafletIfNeeded() {
      if (leafletPromise) {
        return leafletPromise;
      }
      leafletPromise = new Promise((resolve, reject) => {
        if (window.L && window.L.map) {
          resolve();
          return;
        }
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        link.integrity = 'sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=';
        link.crossOrigin = '';
        document.head.appendChild(link);

        const script = document.createElement('script');
        script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
        script.integrity = 'sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=';
        script.crossOrigin = '';
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load map library'));
        document.head.appendChild(script);
      });
      return leafletPromise;
    }

    function setMapStatus(message) {
      const statusEl = document.getElementById('map-status');
      if (statusEl) {
        statusEl.textContent = message;
      }
    }

    function getLatestPositionIcon() {
      return L.divIcon({
        className: 'latest-position-marker-wrapper',
        html: '<span class="latest-position-marker"></span>',
        iconSize: [20, 20],
        iconAnchor: [10, 10],
      });
    }

    function updateMapOverlay() {
      const overlay = document.getElementById('map-overlay');
      if (!overlay) {
        return;
      }
      if (navigator.onLine) {
        overlay.classList.add('hidden');
      } else {
        overlay.classList.remove('hidden');
      }
    }

    async function ensureMapReady() {
      if (!navigator.onLine) {
        updateMapOverlay();
        return false;
      }
      updateMapOverlay();
      if (mapReady) {
        return true;
      }
      try {
        await loadLeafletIfNeeded();
        const mapContainer = document.getElementById('device-map');
        if (!mapContainer || mapInstance) {
          mapReady = true;
          return true;
        }
        mapInstance = L.map(mapContainer, {
          zoomControl: true,
          attributionControl: true
        }).setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap'
        }).addTo(mapInstance);
        mapReady = true;
        return true;
      } catch (error) {
        console.error(error);
        setMapStatus('Map failed to load.');
        return false;
      }
    }

    async function updateMapLocation() {
      if (!lastPositionMessage) {
        setMapStatus('Waiting for location...');
        return;
      }
      const { latitude, longitude } = lastPositionMessage;
      if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
        setMapStatus('Location unavailable.');
        return;
      }
      const ready = await ensureMapReady();
      if (!ready) {
        setMapStatus('Offline: map unavailable.');
        return;
      }
      setMapStatus(`Location: ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`);
      const coords = [latitude, longitude];
      if (!mapMarker) {
        mapMarker = L.marker(coords, { icon: getLatestPositionIcon() }).addTo(mapInstance);
      } else {
        mapMarker.setLatLng(coords);
      }
      const latestTimestamp = Number.isFinite(lastPositionMessage.timestamp) && lastPositionMessage.timestamp > 0
        ? formatUbloxFixTimestamp(lastPositionMessage.timestamp)
        : 'N/A';
      mapMarker.bindPopup(`Latest known position: ${latestTimestamp}`);
      mapInstance.setView(coords, 14, { animate: false });
    }

    function toggleMapFullscreen() {
      mapFullscreen = !mapFullscreen;
      document.body.classList.toggle('map-fullscreen', mapFullscreen);
      const button = document.getElementById('map-view-toggle');
      if (button) {
        button.textContent = mapFullscreen ? 'Exit fullscreen' : 'Fullscreen';
        button.setAttribute('title', mapFullscreen ? 'Exit fullscreen map' : 'Fullscreen map');
      }
      if (mapInstance) {
        setTimeout(() => mapInstance.invalidateSize(), 0);
      }
    }
    window.toggleMapFullscreen = toggleMapFullscreen;

    function setMapTracksOverlayVisible(visible) {
      const overlay = document.getElementById('map-tracks-overlay');
      if (!overlay) {
        return;
      }
      overlay.classList.toggle('hidden', !visible);
    }

    function showMapTracksOverlay({ title, text, loading = false }) {
      const titleEl = document.getElementById('map-tracks-title');
      const textEl = document.getElementById('map-tracks-text');
      const spinner = document.getElementById('map-tracks-spinner');
      const okButton = document.getElementById('map-tracks-ok');
      if (!titleEl || !textEl || !spinner || !okButton) {
        return;
      }
      titleEl.textContent = title;
      textEl.textContent = text;
      spinner.classList.toggle('hidden', !loading);
      okButton.classList.toggle('hidden', loading);
      setMapTracksOverlayVisible(true);
    }

    function decodeTrackPointFromFullMessage(bytes) {
      if (!bytes || bytes.length < 30) {
        return null;
      }
      try {
        const decoded = decodeUbloxFixMessage(bytes);
        return {
          latitude: decoded.latitude,
          longitude: decoded.longitude,
          timestamp: decoded.fix_timestamp || 0
        };
      } catch (error) {
        return null;
      }
    }

    function decodeTrackPointFromShortMessage(bytes) {
      if (!bytes || bytes.length < 12) {
        return null;
      }
      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      const first = view.getInt32(0, true) / 1e7;
      const second = view.getInt32(4, true) / 1e7;
      const timestamp = view.getUint32(8, true);

      const lonFirstCandidate = {
        latitude: second,
        longitude: first,
        timestamp,
      };
      const latFirstCandidate = {
        latitude: first,
        longitude: second,
        timestamp,
      };
      const isValid = (point) => Number.isFinite(point.latitude) && Number.isFinite(point.longitude)
        && point.latitude >= -90 && point.latitude <= 90
        && point.longitude >= -180 && point.longitude <= 180;

      if (isValid(lonFirstCandidate)) {
        return lonFirstCandidate;
      }
      if (isValid(latFirstCandidate)) {
        return latFirstCandidate;
      }
      return null;
    }

    function filterAndSortTrackPoints(points) {
      return points
        .filter((point) => Number.isFinite(point.latitude) && Number.isFinite(point.longitude))
        .filter((point) => point.latitude !== 0 && point.longitude !== 0)
        .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
    }

    async function renderTrackOnMap(points) {
      const ready = await ensureMapReady();
      if (!ready || !mapInstance) {
        showMapTracksOverlay({
          title: 'Map unavailable',
          text: 'Could not load map tiles. Please check your connection and try again.',
          loading: false,
        });
        return;
      }

      if (mapTrackLayer) {
        mapInstance.removeLayer(mapTrackLayer);
        mapTrackLayer = null;
      }
      if (mapTrackLatestMarker) {
        mapInstance.removeLayer(mapTrackLatestMarker);
        mapTrackLatestMarker = null;
      }

      const coords = points.map((point) => [point.latitude, point.longitude]);
      mapTrackLayer = L.layerGroup();
      L.polyline(coords, {
        color: '#1f6feb',
        weight: 3,
        opacity: 0.85
      }).addTo(mapTrackLayer);
      points.forEach((point) => {
        const marker = L.circleMarker([point.latitude, point.longitude], {
          radius: 4,
          color: '#1f6feb',
          weight: 1,
          fillColor: '#7bb1ff',
          fillOpacity: 0.9
        }).addTo(mapTrackLayer);
        marker.bindPopup(`Time: ${formatUbloxFixTimestamp(point.timestamp)}`);
      });
      mapTrackLayer.addTo(mapInstance);

      const latest = points.reduce((current, point) => ((point.timestamp || 0) >= (current.timestamp || 0) ? point : current), points[0]);
      mapTrackLatestMarker = L.marker([latest.latitude, latest.longitude]).addTo(mapInstance);
      mapTrackLatestMarker.bindPopup(`Latest track point: ${formatUbloxFixTimestamp(latest.timestamp)}`);

      const bounds = L.latLngBounds(coords);
      if (bounds.isValid()) {
        mapInstance.fitBounds(bounds, { padding: [24, 24] });
      } else {
        mapInstance.setView([latest.latitude, latest.longitude], 14, { animate: false });
      }
      setMapStatus(`Track loaded: ${points.length} point(s).`);
    }

    function buildTrackPayloadPlans(port, startIndex) {
      const startIndexFromHead = Math.max(0, startIndex);
      const plans = [];
      for (let offset = 0; offset < TRACK_POINTS_LIMIT; offset++) {
        const payload12 = new Uint8Array(12);
        const view12 = new DataView(payload12.buffer);
        view12.setUint32(0, port, true);
        view12.setUint32(4, startIndexFromHead + offset, true);
        view12.setUint32(8, 1, true);
        plans.push({
          key: `u32-port,u32-index=${startIndexFromHead + offset},u32-count=1`,
          bytes: payload12
        });
      }
      return plans;
    }

    function executeNextTrackPlan() {
      if (!mapTrackState.active || !mapTrackState.pendingPlans.length) {
        return false;
      }
      const cmd = settingsData && settingsData.commands ? settingsData.commands.cmd_flash_get_from_head : null;
      if (!cmd) {
        return false;
      }
      const plan = mapTrackState.pendingPlans.shift();
      showMapTracksOverlay({
        title: mapTrackState.phase === 'full' ? 'Loading UBLOX tracks...' : 'Loading UBLOX short tracks...',
        text: `Reading up to ${TRACK_POINTS_LIMIT} points from device flash.`,
        loading: true,
      });
      executeBleCommand([0x20, parseInt(cmd.id, 16), plan.bytes.length, ...plan.bytes]);
      return true;
    }

    function startTrackRequest(mode) {
      const cmd = settingsData && settingsData.commands ? settingsData.commands.cmd_flash_get_from_head : null;
      if (!cmd) {
        showToast('Flash get from head command not available.');
        return;
      }

      const fullPort = settingsData && settingsData.ports ? settingsData.ports.port_ublox_gps : null;
      const shortPort = settingsData && settingsData.ports ? settingsData.ports.port_ublox_short_message : null;
      const port = mode === 'full' ? fullPort : shortPort;
      if (!Number.isFinite(port)) {
        showToast('Required UBLOX port not available in this firmware.');
        return;
      }
      // Device uses "from head" indexing where 0 means newest entry (look back from latest).
      // To fetch the latest N points, always start from 0.
      const startIndex = 0;

      mapTrackState.active = true;
      mapTrackState.phase = mode;
      mapTrackState.points = [];
      mapTrackState.pendingPlans = buildTrackPayloadPlans(port, startIndex);
      mapTrackState.flashBuffer = new Uint8Array(0);
      log(`Track request start: phase=${mode}, strategy=single, port=${port}, startIndex(from head)=${startIndex}, count=${TRACK_POINTS_LIMIT}, payloads=${mapTrackState.pendingPlans.length}`);
      if (!executeNextTrackPlan()) {
        mapTrackState.active = false;
        showMapTracksOverlay({
          title: 'Track request failed',
          text: 'Could not prepare request payload.',
          loading: false,
        });
      }
    }

    function getTracks() {
      if (!settingsData || !settingsData.messages) {
        showToast('Load settings first.');
        return;
      }
      if (!document.body.classList.contains('connected') || !rxCharacteristic) {
        showToast('Connect to a device first.');
        return;
      }
      if (mapTrackState.active) {
        showToast('Track request already in progress.');
        return;
      }
      startTrackRequest('full');
    }
    window.getTracks = getTracks;

    function handleTrackCommandConfirm(status) {
      if (!mapTrackState.active) {
        return;
      }
      log(`Track request confirm: phase=${mapTrackState.phase}, status=0x${status.toString(16).padStart(2, '0')}, decodedPoints=${mapTrackState.points.length}, bufferedBytes=${mapTrackState.flashBuffer.length}`);

      if (status !== 0x01) {
        if (executeNextTrackPlan()) {
          return;
        }
        if (mapTrackState.points.length > 0) {
          // Some firmwares signal end-of-window with non-success when the requested
          // range extends beyond available records. Keep already decoded points.
        } else if (mapTrackState.phase === 'full') {
          startTrackRequest('short');
          return;
        } else {
          mapTrackState.active = false;
          showMapTracksOverlay({
            title: 'Track request failed',
            text: `Device returned status 0x${status.toString(16).padStart(2, '0')}.`,
            loading: false,
          });
          return;
        }
      }

      if (executeNextTrackPlan()) {
        return;
      }

      const rawCount = mapTrackState.points.length;
      const filtered = filterAndSortTrackPoints(mapTrackState.points);
      log(`Track decode summary: phase=${mapTrackState.phase}, rawPoints=${rawCount}, filteredPoints=${filtered.length}`);
      if (filtered.length && lastPositionMessage && Number.isFinite(lastPositionMessage.timestamp)) {
        const newestTrack = filtered[filtered.length - 1];
        const deltaSeconds = (lastPositionMessage.timestamp || 0) - (newestTrack.timestamp || 0);
        log(`Track vs last-known timestamp delta: ${deltaSeconds}s (last_known=${lastPositionMessage.timestamp}, newest_track=${newestTrack.timestamp || 0})`);
      }
      if (mapTrackState.phase === 'full' && rawCount === 0) {
        startTrackRequest('short');
        return;
      }

      mapTrackState.active = false;
      if (!filtered.length) {
        showMapTracksOverlay({
          title: 'No track logs available',
          text: mapTrackState.phase === 'short'
            ? 'No msg_ublox_location or msg_ublox_location_short logs were found.'
            : 'No msg_ublox_location logs were found.',
          loading: false,
        });
        return;
      }

      setMapTracksOverlayVisible(false);
      renderTrackOnMap(filtered);
    }

    function tryHandleTrackResponse(data) {
      if (!mapTrackState.active || !settingsData) {
        return false;
      }

      const port = data[0];
      const id = data[1];
      const flashLogPort = settingsData.ports ? settingsData.ports.port_flash_log : null;
      const messagesPort = settingsData.ports ? settingsData.ports.port_messages : null;
      if (port === messagesPort && id === MSG_CMD_CONFIRM && data.length >= 5 && data[3] === CMD_FLASH_GET_FROM_HEAD) {
        handleTrackCommandConfirm(data[4]);
        return true;
      }

      const messageKey = mapTrackState.phase === 'full' ? 'msg_ublox_location' : 'msg_ublox_location_short';
      const messageMeta = settingsData.messages[messageKey];
      if (!messageMeta || !settingsData.ports) {
        return false;
      }
      const expectedPort = settingsData.ports[messageMeta.port];
      const expectedId = parseInt(messageMeta.id, 16);
      if (Number.isFinite(flashLogPort) && port === flashLogPort) {
        const incoming = data.slice(1);
        const merged = new Uint8Array(mapTrackState.flashBuffer.length + incoming.length);
        merged.set(mapTrackState.flashBuffer, 0);
        merged.set(incoming, mapTrackState.flashBuffer.length);

        let index = 0;
        while (index + 2 < merged.length) {
          const nestedPort = merged[index];
          const nestedId = merged[index + 1];
          const nestedLen = merged[index + 2];
          const frameStart = index + 3;
          const frameEnd = frameStart + nestedLen;
          const metadataLen = 4;
          const recordEnd = frameEnd + metadataLen;
          if (recordEnd > merged.length) {
            break;
          }
          const nestedPayload = merged.slice(frameStart, frameEnd);
          index = recordEnd;

          if (nestedPort !== expectedPort || nestedId !== expectedId) {
            continue;
          }
          const point = mapTrackState.phase === 'full'
            ? decodeTrackPointFromFullMessage(nestedPayload)
            : decodeTrackPointFromShortMessage(nestedPayload);
          if (point) {
            mapTrackState.points.push(point);
          }
        }
        mapTrackState.flashBuffer = merged.slice(index);
        return true;
      }

      if (port !== expectedPort || id !== expectedId) {
        return false;
      }

      let payloadLength = data.length >= 3 ? data[2] : 0;
      if (payloadLength <= 0 || payloadLength > data.length - 3) {
        payloadLength = data.length - 3;
      }
      const payload = data.slice(3, 3 + payloadLength);
      const point = mapTrackState.phase === 'full'
        ? decodeTrackPointFromFullMessage(payload)
        : decodeTrackPointFromShortMessage(payload);
      if (point) {
        mapTrackState.points.push(point);
      }
      return true;
    }

    function handleConnectivityChange() {
      updateMapOverlay();
      if (navigator.onLine && lastPositionMessage) {
        updateMapLocation();
      }
    }

    window.addEventListener('online', handleConnectivityChange);
    window.addEventListener('offline', handleConnectivityChange);
    updateMapOverlay();
    const mapDetails = document.querySelector('#map-area details');
    if (mapDetails) {
      mapDetails.addEventListener('toggle', () => {
        if (mapDetails.open && mapInstance) {
          setTimeout(() => mapInstance.invalidateSize(), 0);
        }
      });
    }

    function formatFilenameTimestamp(date) {
      const pad = (num) => num.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}_${pad(date.getHours())}${pad(date.getMinutes())}${pad(date.getSeconds())}`;
    }

    function sanitizeFilenamePart(value) {
      return (value || 'device').toString().replace(/[^A-Za-z0-9_-]+/g, '') || 'device';
    }

    function setFlashLogOverlayVisible(visible) {
      const overlay = document.getElementById('flash-log-overlay');
      if (!overlay) {
        return;
      }
      overlay.classList.toggle('hidden', !visible);
    }

    function clearFlashLogInactivityTimeout() {
      if (flashLogState.inactivityTimeoutId) {
        clearTimeout(flashLogState.inactivityTimeoutId);
        flashLogState.inactivityTimeoutId = null;
      }
    }

    function scheduleFlashLogInactivityTimeout() {
      clearFlashLogInactivityTimeout();
      flashLogState.inactivityTimeoutId = setTimeout(() => {
        if (!flashLogState.active) {
          return;
        }
        showFlashLogFailure('No new log data received for 12 seconds.');
      }, 12000);
    }

    function setFlashLogProgress({ title, detail, received, total, knownTotal, showSpinner = true }) {
      const spinner = document.getElementById('flash-log-overlay-spinner');
      const titleEl = document.getElementById('flash-log-overlay-title');
      const detailEl = document.getElementById('flash-log-overlay-progress-text');
      const progressEl = document.getElementById('flash-log-overlay-progress');
      const barEl = document.getElementById('flash-log-overlay-progress-bar');
      const messageEl = document.getElementById('flash-log-overlay-message');
      const retryBtn = document.getElementById('flash-log-retry');
      const cancelBtn = document.getElementById('flash-log-cancel');
      const eraseBtn = document.getElementById('flash-log-erase');
      const okBtn = document.getElementById('flash-log-ok');
      if (!spinner || !titleEl || !detailEl || !progressEl || !barEl || !messageEl || !retryBtn || !cancelBtn || !eraseBtn || !okBtn) {
        return;
      }

      titleEl.textContent = title;
      detailEl.textContent = detail;
      spinner.classList.toggle('hidden', !showSpinner);
      progressEl.classList.remove('hidden');
      progressEl.classList.toggle('indeterminate', !knownTotal);
      if (knownTotal && Number.isFinite(total) && total > 0) {
        const percent = Math.max(0, Math.min(100, Math.round((received / total) * 100)));
        barEl.style.width = `${percent}%`;
      } else {
        barEl.style.width = '35%';
      }
      messageEl.classList.add('hidden');
      messageEl.classList.remove('warning');
      retryBtn.classList.add('hidden');
      cancelBtn.classList.remove('hidden');
      eraseBtn.classList.add('hidden');
      okBtn.classList.add('hidden');
      setFlashLogOverlayVisible(true);
    }

    function buildFlashLogFilename() {
      const startedAt = flashLogState.startedAt || new Date();
      const deviceName = sanitizeFilenamePart(flashLogState.deviceName);
      const logType = sanitizeFilenamePart(flashLogState.logTypeLabel || 'all');
      const timestamp = formatFilenameTimestamp(startedAt);
      return `raw_logs-${logType}-${deviceName}_${timestamp}.txt`;
    }

    function showFlashLogSuccess(filename) {
      const spinner = document.getElementById('flash-log-overlay-spinner');
      const titleEl = document.getElementById('flash-log-overlay-title');
      const detailEl = document.getElementById('flash-log-overlay-progress-text');
      const progressEl = document.getElementById('flash-log-overlay-progress');
      const barEl = document.getElementById('flash-log-overlay-progress-bar');
      const messageEl = document.getElementById('flash-log-overlay-message');
      const retryBtn = document.getElementById('flash-log-retry');
      const cancelBtn = document.getElementById('flash-log-cancel');
      const eraseBtn = document.getElementById('flash-log-erase');
      const okBtn = document.getElementById('flash-log-ok');
      if (!spinner || !titleEl || !detailEl || !progressEl || !barEl || !messageEl || !retryBtn || !cancelBtn || !eraseBtn || !okBtn) {
        return;
      }

      spinner.classList.add('hidden');
      titleEl.textContent = 'Log download complete';
      detailEl.textContent = `Downloaded file: ${filename}`;
      progressEl.classList.remove('hidden');
      progressEl.classList.remove('indeterminate');
      barEl.style.width = '100%';
      messageEl.innerHTML = `
        Use the <a href="https://smartparksorg.github.io/raw_logs_decoder/" target="_blank" rel="noopener noreferrer">Smart Parks - Log File Decoder</a>
        to decode this log file.
      `;
      messageEl.classList.remove('hidden');
      messageEl.classList.remove('warning');
      retryBtn.classList.add('hidden');
      cancelBtn.classList.add('hidden');
      eraseBtn.classList.remove('hidden');
      okBtn.classList.remove('hidden');
      setFlashLogOverlayVisible(true);
    }

    function showFlashLogNoData() {
      const spinner = document.getElementById('flash-log-overlay-spinner');
      const titleEl = document.getElementById('flash-log-overlay-title');
      const detailEl = document.getElementById('flash-log-overlay-progress-text');
      const progressEl = document.getElementById('flash-log-overlay-progress');
      const messageEl = document.getElementById('flash-log-overlay-message');
      const retryBtn = document.getElementById('flash-log-retry');
      const cancelBtn = document.getElementById('flash-log-cancel');
      const eraseBtn = document.getElementById('flash-log-erase');
      const okBtn = document.getElementById('flash-log-ok');
      if (!spinner || !titleEl || !detailEl || !progressEl || !messageEl || !retryBtn || !cancelBtn || !eraseBtn || !okBtn) {
        return;
      }

      const isAll = flashLogState.requestMode === 'all';
      const scopeLabel = isAll ? 'for this device' : `for "${flashLogState.logTypeLabel}"`;
      spinner.classList.add('hidden');
      titleEl.textContent = 'No logs available';
      detailEl.textContent = `The device has no stored log messages ${scopeLabel}.`;
      progressEl.classList.add('hidden');
      messageEl.textContent = 'No file was downloaded.';
      messageEl.classList.remove('hidden');
      messageEl.classList.remove('warning');
      retryBtn.classList.add('hidden');
      cancelBtn.classList.add('hidden');
      eraseBtn.classList.remove('hidden');
      okBtn.classList.remove('hidden');
      setFlashLogOverlayVisible(true);
    }

    function showFlashLogFailure(reason = 'Log download stopped prematurely.') {
      clearFlashLogInactivityTimeout();
      flashLogState.active = false;
      flashLogState.lastError = reason;

      const spinner = document.getElementById('flash-log-overlay-spinner');
      const titleEl = document.getElementById('flash-log-overlay-title');
      const detailEl = document.getElementById('flash-log-overlay-progress-text');
      const messageEl = document.getElementById('flash-log-overlay-message');
      const retryBtn = document.getElementById('flash-log-retry');
      const cancelBtn = document.getElementById('flash-log-cancel');
      const eraseBtn = document.getElementById('flash-log-erase');
      const okBtn = document.getElementById('flash-log-ok');
      if (!spinner || !titleEl || !detailEl || !messageEl || !retryBtn || !cancelBtn || !eraseBtn || !okBtn) {
        return;
      }

      spinner.classList.add('hidden');
      titleEl.textContent = 'Log download failed';
      detailEl.textContent = reason;
      const progressEl = document.getElementById('flash-log-overlay-progress');
      if (progressEl) {
        progressEl.classList.remove('hidden');
      }
      messageEl.textContent = 'You can retry the download or cancel.';
      messageEl.classList.remove('hidden');
      messageEl.classList.add('warning');
      retryBtn.classList.remove('hidden');
      cancelBtn.classList.remove('hidden');
      eraseBtn.classList.add('hidden');
      okBtn.classList.add('hidden');
      setFlashLogOverlayVisible(true);
      log(`Flash log download failed: ${reason}`, true);
    }

    function startFlashLogCapture({ logTypeLabel = 'all', requestMode = 'all', requestedPort = 0, expectedTotal = null } = {}) {
      clearFlashLogInactivityTimeout();
      flashLogState = {
        active: true,
        lines: [],
        buffer: '',
        startedAt: new Date(),
        deviceName: device && device.name ? device.name : '',
        logTypeLabel,
        requestMode,
        requestedPort,
        expectedTotal,
        inactivityTimeoutId: null,
        lastFilename: '',
        lastError: '',
        lastRequest: { logTypeLabel, requestMode, requestedPort, expectedTotal }
      };
      const detail = Number.isFinite(expectedTotal) && expectedTotal > 0
        ? `Received 0/${expectedTotal} messages (0%)`
        : 'Received 0 messages';
      setFlashLogProgress({
        title: `Downloading logs (${logTypeLabel})...`,
        detail,
        received: 0,
        total: expectedTotal,
        knownTotal: Number.isFinite(expectedTotal) && expectedTotal > 0
      });
      scheduleFlashLogInactivityTimeout();
      log(`Starting flash log download (${logTypeLabel})...`);
    }

    function finishFlashLogCapture(reason) {
      if (!flashLogState.active) {
        return;
      }
      clearFlashLogInactivityTimeout();

      if (flashLogState.buffer) {
        flashLogState.lines.push(flashLogState.buffer);
        flashLogState.buffer = '';
      }

      const lines = flashLogState.lines;
      if (lines.length === 0 && reason === 'device confirm') {
        flashLogState.active = false;
        showFlashLogNoData();
        log(`Flash log download finished with no data (${flashLogState.logTypeLabel}).`);
        return;
      }
      const filename = buildFlashLogFilename();
      flashLogState.lastFilename = filename;

      const contents = lines.join('\n');
      const blob = new Blob([contents], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);

      log(`Flash log download complete (${lines.length} lines). File: ${filename}${reason ? ` (${reason})` : ''}`);
      flashLogState.active = false;
      showFlashLogSuccess(filename);
    }

    function bytesToBase64(bytes) {
      let binary = '';
      bytes.forEach((byte) => {
        binary += String.fromCharCode(byte);
      });
      return btoa(binary);
    }

    function handleFlashLogChunk(data) {
      if (!flashLogState.active) {
        return;
      }
      scheduleFlashLogInactivityTimeout();
      let payloadLength = data.length >= 3 ? data[2] : 0;
      if (payloadLength === 0 || payloadLength > data.length - 3) {
        payloadLength = data.length - 3;
      }

      if (payloadLength <= 0 && data.length <= 3) {
        showFlashLogFailure('Device returned an empty payload.');
        return;
      }

      const payload = data.slice(0);
      if (!payload.length) {
        return;
      }

      const base64Line = bytesToBase64(payload);
      flashLogState.lines.push(base64Line);
      const receivedCount = flashLogState.lines.length;
      const elapsedSeconds = Math.max(1, Math.round((Date.now() - flashLogState.startedAt.getTime()) / 1000));
      const rate = (receivedCount / elapsedSeconds).toFixed(1);
      const hasTotal = Number.isFinite(flashLogState.expectedTotal) && flashLogState.expectedTotal > 0;
      const detail = hasTotal
        ? `Received ${receivedCount}/${flashLogState.expectedTotal} messages (${Math.min(100, Math.round((receivedCount / flashLogState.expectedTotal) * 100))}%)`
        : `Received ${receivedCount} messages (${rate}/s)`;
      setFlashLogProgress({
        title: `Downloading logs (${flashLogState.logTypeLabel})...`,
        detail,
        received: receivedCount,
        total: flashLogState.expectedTotal,
        knownTotal: hasTotal
      });
      log(`Flash log: ${base64Line}`);
    }

    async function loadSelectedSettings() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      if (!selectedFile) {
        return;
      }

      log(`Loading settings from ${selectedFile}...`);

      try {
        document.getElementById('settings-search').value = '';
        await loadSettings(selectedFile);
        log(`Settings from ${selectedFile} loaded successfully.`);
        displaySettings();
        displayMainCommands();
        displayCommands();
        populateFlashLogTypeOptions();
        document.body.classList.add('has-settings');
        await fetchAllSettings();
        requestFlashLogCount();
      } catch (error) {
        console.error(error);
        log(`Error loading settings: ${error.message}`, true);
      }
    };

    function exportToJson() {
      const settings = {};
      const includeCredentials = document.getElementById('export-credentials-toggle')?.checked ?? true;

      for (const [key, setting] of Object.entries(settingsData.settings)) {
        if (excludeFromImportExport.includes(key)) {
          continue;
        }
        if (!includeCredentials && isCredentialSetting(setting)) {
          continue;
        }

        const value = getInputValue(setting.id);

        if (['uint32', 'uint16', 'uint8', 'int32', 'int8', 'float'].includes(setting.conversion)) {
          settings[key] = Number(value);
        } else if (setting.conversion === 'bool') {
          settings[key] = value === 'true';
        } else {
          settings[key] = value;
        }
      }

      const json = JSON.stringify(settings, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      const deviceName = (getInputValue(settingsData.settings?.device_name?.id) || 'device')
        .toString()
        .trim()
        .replace(/[^A-Za-z0-9_-]+/g, '_')
        .replace(/^_+|_+$/g, '') || 'device';
      const now = new Date();
      const pad = (value) => String(value).padStart(2, '0');
      const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
      a.download = `${deviceName}_${timestamp}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function showImportPreviewModal({ title, subtitle, rows, note }) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('import-preview-overlay');
        const titleEl = document.getElementById('import-preview-title');
        const subtitleEl = document.getElementById('import-preview-subtitle');
        const noteEl = document.getElementById('import-preview-note');
        const rowsEl = document.getElementById('import-preview-rows');
        const progressEl = document.getElementById('import-preview-progress');
        const changedOnlyToggle = document.getElementById('import-preview-changed-only');
        const cancelBtn = document.getElementById('import-preview-cancel');
        const confirmBtn = document.getElementById('import-preview-confirm');

        titleEl.textContent = title;
        subtitleEl.textContent = subtitle;
        if (noteEl) {
          noteEl.textContent = note || '';
          noteEl.classList.toggle('hidden', !note);
        }
        if (progressEl) {
          progressEl.classList.add('hidden');
        }
        if (confirmBtn) {
          confirmBtn.classList.remove('hidden');
        }
        if (cancelBtn) {
          cancelBtn.textContent = 'Cancel';
          cancelBtn.onclick = null;
        }
        function renderRows() {
          const changedOnly = changedOnlyToggle ? changedOnlyToggle.checked : false;
          rowsEl.innerHTML = rows.filter(row => !changedOnly || !row.unchanged).map((row) => `
          <tr class="${row.unchanged ? 'import-preview-unchanged' : ''}" data-setting-id="${row.id}">
            <td>
              <div class="import-preview-setting">${row.name}</div>
              <div class="import-preview-meta">${row.key} (${row.id})</div>
              ${row.description ? `<div class="import-preview-desc">${row.description}</div>` : ''}
            </td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">${row.current}</td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">
              ${row.next}
              ${row.unchanged ? '<div class="import-preview-unchanged-tag">unchanged</div>' : '<div class="import-preview-change-tag">change</div>'}
            </td>
          </tr>
          `).join('');
        }
        renderRows();
        if (changedOnlyToggle) {
          changedOnlyToggle.onchange = renderRows;
        }

        function cleanup(result) {
          overlay.classList.add('hidden');
          cancelBtn.removeEventListener('click', onCancel);
          confirmBtn.removeEventListener('click', onConfirm);
          resolve(result);
        }

        function onCancel() {
          cleanup(false);
        }

        function onConfirm() {
          cleanup(true);
        }

        cancelBtn.addEventListener('click', onCancel);
        confirmBtn.addEventListener('click', onConfirm);
        overlay.classList.remove('hidden');
      });
    }

    function showImportProgress({ total, title, subtitle, items }) {
      const overlay = document.getElementById('import-preview-overlay');
      const titleEl = document.getElementById('import-preview-title');
      const subtitleEl = document.getElementById('import-preview-subtitle');
      const rowsEl = document.getElementById('import-preview-rows');
      const progressEl = document.getElementById('import-preview-progress');
      const progressText = document.getElementById('import-preview-progress-text');
      const progressBar = document.getElementById('import-preview-progress-bar');
      const confirmBtn = document.getElementById('import-preview-confirm');
      const cancelBtn = document.getElementById('import-preview-cancel');

      if (titleEl) titleEl.textContent = title || 'Importing settings';
      if (subtitleEl) subtitleEl.textContent = subtitle || '';
      if (rowsEl && Array.isArray(items)) {
        rowsEl.innerHTML = items.map((row) => `
          <tr class="${row.unchanged ? 'import-preview-unchanged' : ''}" data-setting-id="${row.id}">
            <td>
              <div class="import-preview-setting">${row.name}</div>
              <div class="import-preview-meta">${row.key} (${row.id})</div>
              ${row.description ? `<div class="import-preview-desc">${row.description}</div>` : ''}
            </td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">${row.current}</td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">
              ${row.next}
              ${row.unchanged ? '<div class="import-preview-unchanged-tag">unchanged</div>' : '<div class="import-preview-change-tag">change</div>'}
            </td>
          </tr>
        `).join('');
      }
      if (progressText) progressText.textContent = `Applying settings... (0/${total})`;
      if (progressBar) progressBar.style.width = '0%';
      if (progressEl) progressEl.classList.remove('hidden');
      if (confirmBtn) confirmBtn.classList.add('hidden');
      if (cancelBtn) {
        cancelBtn.disabled = true;
        cancelBtn.textContent = 'Close';
        cancelBtn.onclick = () => {
          overlay.classList.add('hidden');
        };
      }
      if (overlay) overlay.classList.remove('hidden');
    }

    function updateImportProgress({ index, total, label, status, settingId }) {
      const progressText = document.getElementById('import-preview-progress-text');
      const progressBar = document.getElementById('import-preview-progress-bar');
      if (progressText) {
        progressText.textContent = `Applying settings... (${index}/${total})`;
      }
      if (progressBar) {
        const safeTotal = total || 1;
        progressBar.style.width = `${(index / safeTotal) * 100}%`;
      }
      if (!settingId) return;
      const row = document.querySelector(`tr[data-setting-id="${settingId}"]`);
      if (!row) return;
      const tag = row.querySelector('.import-preview-change-tag');
      if (!tag) return;
      if (status === 'success') {
        tag.textContent = 'updated';
        tag.classList.add('updated');
        tag.classList.remove('error');
      } else if (status === 'error') {
        tag.textContent = 'error';
        tag.classList.add('error');
        tag.classList.remove('updated');
      }
      row.scrollIntoView({ block: 'nearest' });
    }

    function finishImportProgress({ total, success }) {
      const progressText = document.getElementById('import-preview-progress-text');
      const cancelBtn = document.getElementById('import-preview-cancel');
      if (progressText) {
        progressText.textContent = success
          ? `Import complete. (${total}/${total})`
          : `Import stopped. (${total} attempted)`;
      }
      if (cancelBtn) cancelBtn.disabled = false;
    }

    async function importFromJson() {
      const fileInput = document.getElementById('import-file');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a file to import.');
        return;
      }

      console.log('Importing settings from file:', file.name);
      const reader = new FileReader();
      reader.onload = async function (event) {
        const settingsSection = document.getElementById('settings-section');
        const commandsSection = document.getElementById('other-commands');
        const search = document.getElementById('search');
        document.getElementById('settings-search').value = '';
        filterSettings();

        let filteredEntries = [];
        try {
          const importedSettings = JSON.parse(event.target.result);
          const previewRows = [];
          const includeCredentials = document.getElementById('import-credentials-toggle')?.checked ?? false;

          let index = 0;
          const entries = Object.entries(importedSettings).filter(([key]) => !excludeFromImportExport.includes(key));
          filteredEntries = [];

          for (const [key, value] of entries) {
            const settingObj = getByKey(key);
            if (!settingObj) {
              continue;
            }
            if (!includeCredentials && isCredentialSetting(settingObj)) {
              continue;
            }
            const currentValue = getInputValue(settingObj.id) ?? settingObj.default;
            const unchanged = isSettingValueEqual(key, settingObj, currentValue, value);
            if (!unchanged) {
              filteredEntries.push([key, value]);
            }
            previewRows.push({
              key,
              id: settingObj.id,
              name: settingObj.display_name || key,
              description: getSettingDescription(key),
              current: formatSettingValueForPreview(key, settingObj, currentValue, value, 'current'),
              next: formatSettingValueForPreview(key, settingObj, value, currentValue, 'next'),
              unchanged
            });
          }

          if (previewRows.length === 0) {
            showToast('No valid settings found in the import file.');
            return;
          }
          if (filteredEntries.length === 0) {
            showToast('All selected settings already match the device.');
            return;
          }

          const ok = await showImportPreviewModal({
            title: `Import ${previewRows.length} settings`,
            subtitle: `File: ${file.name}`,
            rows: previewRows,
            note: includeCredentials ? '' : 'Device credentials will be skipped.'
          });
          if (!ok) {
            showToast('Import cancelled');
            return;
          }

          showImportProgress({
            total: filteredEntries.length,
            title: `Importing ${filteredEntries.length} settings`,
            subtitle: `File: ${file.name}`,
            items: previewRows
          });

          search.classList.add('hidden');
          settingsSection.classList.add('hidden');
          commandsSection.classList.add('hidden');

          for (const [key, value] of filteredEntries) {
            index++;

            const settingObj = getByKey(key);
            if (settingObj) {
              const label = `${settingObj.display_name || key} (${settingObj.id})`;
              try {
                const start = Date.now();
                await updateBleSetting(settingObj.id, value);
                const elapsed = Date.now() - start;
                const remainingSleep = Math.max(0, 200 - elapsed);
                if (remainingSleep > 0) {
                  await sleep(remainingSleep);
                }
                updateImportProgress({ index, total: filteredEntries.length, label, status: 'success', settingId: settingObj.id });
              } catch (error) {
                updateImportProgress({ index, total: filteredEntries.length, label, status: 'error', settingId: settingObj.id });
                throw error;
              }
            }
          }

          await fetchAllSettings();
          finishImportProgress({ total: filteredEntries.length, success: true });
        } catch (error) {
          console.error('Error importing settings:', error);
          showToast('Failed to import settings. Please check the file format.');
          finishImportProgress({ total: filteredEntries.length || 0, success: false });
        } finally {
          search.classList.remove('hidden');
          settingsSection.classList.remove('hidden');
          commandsSection.classList.remove('hidden');
        }
        fileInput.value = '';
      };
      reader.readAsText(file);
    }

    function loadAvailableSettings() {
      try {
        populateSettingsIntoPage("Choose a settings file");
      } catch (error) {
        log(`Error fetching settings files: ${error.message}`, true);
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function decodeHwFwType(t) {
      switch (t) {
        case 0: return "default";
        case 1: return "rhinoedge";
        case 2: return "elephantedge";
        case 3: return "wisentedge";
        case 4: return "cattracker";
        case 5: return "rangeredge";
        case 6: return "rhinopuck";
        default: return "unknown";
      }
    }

    function decodeReset(reset) {
      switch (reset) {
        case 1: return "RESETPIN";
        case 2: return "DOG";
        case 4: return "SREQ";
        case 8: return "LOCKUP";
        default: return "unknown";
      }
    }


    function decodeStatusMessage(bytes) {
      function decode_uint8(byte, min, max) {
        var val;
        val = byte * (max - min) / 255 + min;
        return val;
      }
      // Skip header 0 and 1
      var reset = bytes[2];
      var err = bytes[3];
      var bat = (bytes[4] * 10) + 2500;
      var operation = bytes[5];
      var msg = 0;
      if (operation & 1) msg = 1;
      var locked = 0;
      if (operation & 2) locked = 1;
      var lr_join = 0;
      if (operation & 4) lr_join = 1;
      var lr_sat = operation >> 4;
      var temp = decode_uint8(bytes[6], -100, 100);
      var uptime = bytes[7];
      var acc_x = decode_uint8(bytes[8], -100, 100);
      var acc_y = decode_uint8(bytes[9], -100, 100);
      var acc_z = decode_uint8(bytes[10], -100, 100);
      var version = bytes[11];
      var ver_hw_minor = version & 0x0F;
      var ver_hw_major = version >> 4;
      version = bytes[12];
      var ver_fw_minor = version & 0x0F;
      var ver_fw_major = version >> 4;
      var ver_hw_type = bytes[13] & 0x0F;
      var ver_fw_type = bytes[13] >> 4;
      var chg = 0;
      if (bytes[14] > 0) chg = (bytes[14] * 100) + 5000;
      var features = bytes[15];
      var sat_support = 0;
      if (features & 1) sat_support = 1;
      var rf_scan = 0;
      if (features & 2) rf_scan = 1;
      var fence = 0;
      if (features & 4) fence = 1;
      var sat_try = features >> 4;
      //Errors
      var err_lr = 0;
      if (err & 1) err_lr = 1;
      var err_ble = 0;
      if (err & 2) err_ble = 1;
      var err_ublox = 0;
      if (err & 4) err_ublox = 1;
      var err_acc = 0;
      if (err & 8) err_acc = 1;
      var err_bat = 0;
      if (err & 16) err_bat = 1;
      var err_ublox_fix = 0;
      if (err & 32) err_ublox_fix = 1;
      var err_flash = 0;
      if (err & 64) err_flash = 1;
      var ublox_busy = 0;
      if (err & 128) ublox_busy = 1;
      return {
        reset: reset,
        bat: bat,
        chg: chg,
        temp: temp,
        uptime: uptime,
        locked: locked,
        msg: msg,
        acc_x: acc_x,
        acc_y: acc_y,
        acc_z: acc_z,
        lr_sat: lr_sat,
        err_lr: err_lr,
        err_lr_join: lr_join,
        err_ble: err_ble,
        err_ublox: err_ublox,
        err_acc: err_acc,
        err_bat: err_bat,
        err_ublox_fix: err_ublox_fix,
        err_flash: err_flash,
        ublox_busy: ublox_busy,
        ver_fw_major: ver_fw_major,
        ver_fw_minor: ver_fw_minor,
        ver_hw_major: ver_hw_major,
        ver_hw_minor: ver_hw_minor,
        ver_hw_type: ver_hw_type,
        ver_fw_type: ver_fw_type,
        sat_support: sat_support,
        sat_try: sat_try,
        rf_scan: rf_scan,
        fence: fence,
      };
    }

    async function displayStatusMessage(statusMessage) {
      const statusMessageElement = document.getElementById('status-message');
      const statusItems = [];
      let lrUpdateBanner = '';

      if (lrUpdateMode) {
        ubloxBusyStatus = Boolean(statusMessage.ublox_busy);
        statusItems.push(
          `<div class="status-item" id="hw-version"><span class="icon hw-version"></span>${statusMessage.ver_hw_major}.${statusMessage.ver_hw_minor}</div>`,
          `<div class="status-item" id="fw-version"><span class="icon fw-version"></span>${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}</div>`,
          `<div class="status-item"><span class="icon uptime"></span>${statusMessage.uptime} day(s)</div>`,
          `<div class="status-item"><span class="icon temperature"></span>${statusMessage.temp.toFixed(1)}C</div>`,
          `<div class="status-item"><span class="icon hw-type"></span>${decodeHwFwType(statusMessage.ver_hw_type)}</div>`
        );
        lrUpdateBanner = `
          <div class="lr-update-banner">
            <div>
              <div class="lr-update-title">Firmware to update the LR chip</div>
              <div class="lr-update-text">Next step: perform DFU to firmware v5 or higher.</div>
            </div>
            <div class="lr-update-actions">
              <button type="button" class="scan-button" onclick="openDfuPage()">Go to DFU</button>
            </div>
          </div>
        `;
      } else {
        const errors = Object.entries(statusMessage)
          .filter(([key, hasError]) => key.startsWith('err_') && hasError)
          .map(([key]) => key.slice(4).toUpperCase())
          .join(', ') || 'no errors';

        statusItems.push(
          `<div class="status-item" id="hw-version"><span class="icon hw-version"></span>${statusMessage.ver_hw_major}.${statusMessage.ver_hw_minor}</div>`,
          `<div class="status-item" id="fw-version"><span class="icon fw-version"></span>${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}</div>`,
          `<div class="status-item"><span class="icon uptime"></span>${statusMessage.uptime} day(s)</div>`,
          `<div class="status-item"><span class="icon temperature"></span>${statusMessage.temp.toFixed(1)}C</div>`,
          `<div class="status-item"><span class="icon hw-type"></span>${decodeHwFwType(statusMessage.ver_hw_type)}</div>`,
          `<div class="status-item"><span class="icon messages"></span>${statusMessage.msg}</div>`,
          `<div class="status-item"><span class="icon battery"></span>${statusMessage.bat}mV</div>`,
          `<div class="status-item"><span class="icon charging"></span>${statusMessage.chg ? 'charging' : 'discharging'}</div>`,
          `<div class="status-item"><span class="icon accelerometer"></span>${statusMessage.acc_x.toFixed(1)}, ${statusMessage.acc_y.toFixed(1)}, ${statusMessage.acc_z.toFixed(1)}</div>`,
          `<div class="status-item"><span class="icon locked"></span>${statusMessage.locked ? 'PIN set' : 'PIN not set'}</div>`,
          `<div class="status-item"><span class="icon ublox-location"></span>${statusMessage.ublox_busy ? 'UBLOX busy' : 'UBLOX idle'}</div>`,
          `<div class="status-item"><span class="icon reset"></span>${decodeReset(statusMessage.reset)}</div>`,
          `<div class="status-item"><span class="icon ublox-time"></span><span id="ublox-timestamp">fetching time...</span></div>`,
          `<div class="status-item"><span class="icon ublox-location"></span><span id="ublox-location">fetching location...</span></div>`,
          `<div class="status-item"><span class="icon errors"></span>${errors}</div>`
        );
      }

      statusMessageElement.innerHTML = `
        <div class="status-header">
          <h4>${device.name}</h4>
          <a href="#" onclick="requestStatusMessage()">
            <div class="status-item"><span class="icon refresh"></span>refresh</div>
          </a>
        </div>
        ${lrUpdateBanner}
        <div class="status-items">
          ${statusItems.join('')}
        </div>
      `;

      displayMainCommands();

      try {
        const dfuInfo = {
          deviceName: device && device.name ? device.name : '',
          fwVersion: `${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}`,
          hwVersion: `${statusMessage.ver_hw_major}.${statusMessage.ver_hw_minor}`,
          fwType: statusMessage.ver_fw_type,
          hwType: statusMessage.ver_hw_type,
          updatedAt: Date.now(),
        };
        sessionStorage.setItem('dfuDeviceInfo', JSON.stringify(dfuInfo));
      } catch (error) {
        console.warn('Failed to store DFU device info', error);
      }

      if (!lrUpdateMode) {
        await executeBleCommand([0x20, CMD_SEND_POSITION, 0x00]);

        if (compareSemanticVersion(statusMessage.ver_fw_major, statusMessage.ver_fw_minor, 6, 11) >= 0) {
          await executeBleCommand([0x20, CMD_SEND_TIMESTAMP, 0x00]);
        } else {
          await executeBleCommand([0x20, CMD_SEND_SINGLE_VAL, 0x01, VAL_UBLOX_TIME]);
        }
      }
    }

    function compareSemanticVersion(major1, minor1, major2, minor2) {
      if (major1 > major2) {
        return 1;
      } else if (major1 < major2) {
        return -1;
      } else {
        if (minor1 > minor2) {
          return 1;
        } else if (minor1 < minor2) {
          return -1;
        } else {
          return 0;
        }
      }
    }

    function displaySettings() {
      const settingsSection = document.getElementById('settings-section');
      settingsSection.innerHTML = '';
      for (const [groupName, group] of Object.entries(groupAndSortSettings(settingsData.settings))) {
        const groupWrapper = document.createElement('div');
        groupWrapper.className = 'settings-group is-collapsed';

        const groupToggle = document.createElement('button');
        groupToggle.type = 'button';
        groupToggle.className = 'group-toggle';
        groupToggle.setAttribute('aria-expanded', 'false');
        groupToggle.innerHTML = `
          <span class="group-title">${groupName.replace(/_/g, " ")}</span>
          <span class="group-caret" aria-hidden="true"></span>
        `;
        groupToggle.addEventListener('click', () => toggleGroup(groupWrapper));

        const settingsContainer = document.createElement('div');
        settingsContainer.className = 'settings-container';

        for (const [key, setting] of Object.entries(group)) {
          const row = document.createElement('div');
          row.className = 'setting disabled with-controls';
          row.setAttribute('id', `setting-${setting.id}`);
          const settingDescription = getSettingDescription(key);
          row.setAttribute('data-search', `${key} ${setting.display_name} ${settingDescription}`.trim());
          row.innerHTML = `
          <h4>${setting.display_name} <small>${key} (${setting.id})</small></h4> 
          ${settingDescription ? `<p class="setting-help">${settingDescription}</p>` : ""}
          
          ${renderInput(key, setting)}

          <div class="setting-controls">
            <button id="update-button-${setting.id}" onclick="updateSetting('${setting.id}')">Update</button>
            <button id="reset-button-${setting.id}" onclick="setDefaultValue('${setting.id}')" class="secondary" title="Default value: ${setting.default}">Set default</button>
          </div>
        `;
          settingsContainer.appendChild(row);
        }
        groupWrapper.appendChild(groupToggle);
        groupWrapper.appendChild(settingsContainer);
        settingsSection.appendChild(groupWrapper);
      }
    }

    function displayCommands() {
      const commandsSection = document.getElementById('commands-buttons-section');
      commandsSection.innerHTML = '';
      for (const [key, command] of Object.entries(settingsData.commands)) {
        if ((command.length !== 0 && command.length !== 1) || dangerousCommands.some(rx => rx.test(key)) || key in mainCommands) {
          continue;
        }

        const row = document.createElement('div');
        row.className = 'command';
        row.setAttribute('id', `command-${command.id}`);
        const label = getCommandLabel(key);
        const description = getCommandDescription(key);
        const commandInputMeta = getCommandInputMeta(key);
        let helperHtml = '';
        if (key === 'cmd_send_single_val') {
          const valueOptions = getCommandValueOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Value</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${valueOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        } else if (key === 'cmd_send_single_setting') {
          const settingOptions = getCommandSettingOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Setting</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${settingOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        } else if (commandInputMeta && commandInputMeta.options) {
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Value</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${commandInputMeta.options.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
            </select>
          `;
        } else if (commandInputMeta && commandInputMeta.input) {
          const placeholder = commandInputMeta.input.placeholder || '';
          const labelText = commandInputMeta.input.label || 'Value';
          const dataFormat = commandInputMeta.input.format || 'uint8';
          helperHtml = `
            <label class="command-helper-label" for="command-input-${command.id}">${labelText}</label>
            <input id="command-input-${command.id}" class="command-helper-input" type="text" placeholder="${placeholder}" data-format="${dataFormat}" />
          `;
        }
        row.innerHTML = `
          <button id="command-button-${command.id}" onclick="executeCommand('${command.id}')"${
            description ? ` title="${description}"` : ""
          }>${label}</button>
          ${helperHtml}
          <div class="command-meta">${key} (${command.id})</div>
        `;
        commandsSection.appendChild(row);
      }
    }

    function copyDeviceInfo() {
      if (!settingsData || !settingsData.settings) {
        return;
      }

      function safeGetValue(name) {
        if(name in settingsData.settings) {
          return getInputValue(settingsData.settings[name].id);
        }
      }

      const values = [
        safeGetValue("device_name"),
        safeGetValue("device_eui"),
        safeGetValue("app_key"),
        safeGetValue("app_eui"),
        safeGetValue("device_pin").split("").filter((_, index) => (index + 1) % 2 === 0).join(""),
        document.getElementById('hw-version').textContent,
        document.getElementById('fw-version').textContent,
        safeGetValue("s_band_dev_adr"),
        safeGetValue("s_band_app_key"),
        safeGetValue("s_band_network_key"),
      ].filter(value => value).join("\t");

      navigator.clipboard.writeText(values).then(() => {
        showToast('Device info copied to clipboard');
      }).catch(err => {
        showToast('Failed to copy to clipboard');
      });
    }

    async function loadDfuScriptsIfNeeded() {
      if (window.DfuApp && window.DfuApp.init) {
        return;
      }

      const loadScript = (src) => new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.body.appendChild(script);
      });

      await loadScript('dfu/cbor.js');
      await loadScript('dfu/mcumgr.js');
      await loadScript('dfu/dfu.js');
    }

    function toggleDfuView(showDfu) {
      const sectionsToHide = [
        document.getElementById('settings-area'),
        document.getElementById('other-commands'),
        document.getElementById('map-area'),
      ];
      const container = document.getElementById('container');
      const dfuContainer = document.getElementById('dfu-container');
      const dfuSection = document.getElementById('dfu-section');
      if (showDfu) {
        sectionsToHide.forEach(section => section && section.classList.add('hidden'));
        container && container.classList.add('hidden');
        dfuContainer && dfuContainer.classList.remove('hidden');
        dfuSection && dfuSection.classList.remove('hidden');
        document.body.classList.add('dfu-active');
      } else {
        sectionsToHide.forEach(section => section && section.classList.remove('hidden'));
        container && container.classList.remove('hidden');
        dfuContainer && dfuContainer.classList.add('hidden');
        dfuSection && dfuSection.classList.add('hidden');
        document.body.classList.remove('dfu-active');
      }
    }
    window.toggleDfuView = toggleDfuView;

    function setDfuWarningOverlay(visible) {
      const overlay = document.getElementById('dfu-warning-overlay');
      if (!overlay) return;
      overlay.classList.toggle('hidden', !visible);
    }

    async function proceedOpenDfuPage() {
      if (!document.body.classList.contains('connected')) {
        showToast('Connect to a device before starting DFU.');
        return;
      }
      try {
        await loadDfuScriptsIfNeeded();
        if (window.DfuApp && window.DfuApp.init) {
          window.DfuApp.init({ device, useExistingConnection: true });
        }
        toggleDfuView(true);
      } catch (error) {
        showToast('Failed to load DFU tools.');
        console.error(error);
      }
    }

    async function openDfuPage() {
      setDfuWarningOverlay(true);
    }

    document.getElementById('dfu-back-top').addEventListener('click', () => {
      toggleDfuView(false);
    });

    const dfuWarningCancel = document.getElementById('dfu-warning-cancel');
    const dfuWarningProceed = document.getElementById('dfu-warning-proceed');
    if (dfuWarningCancel) {
      dfuWarningCancel.addEventListener('click', () => setDfuWarningOverlay(false));
    }
    if (dfuWarningProceed) {
      dfuWarningProceed.addEventListener('click', async () => {
        setDfuWarningOverlay(false);
        await proceedOpenDfuPage();
      });
    }

    function sendLocationAndTimeCommand(latitude, longitude) {
      const bytesArray = new Uint8Array(12);
      bytesArray.set(new Uint8Array(new Int32Array([longitude * Math.pow(10, 7)]).buffer), 0);
      bytesArray.set(new Uint8Array(new Int32Array([latitude * Math.pow(10, 7)]).buffer), 4);
      bytesArray.set(new Uint8Array(new Int32Array([new Date() / 1000]).buffer), 8);

      executeBleCommand([0x20, CMD_SET_LOCATION_AND_TIME, 12, ...bytesArray]);
    }

    function setLocationAndTime() {
      if (!navigator.geolocation) {
        alert("Geolocation is not supported by this browser.");
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          log(`Got location: ${position.coords.latitude}, ${position.coords.longitude}`);
          sendLocationAndTimeCommand(position.coords.latitude, position.coords.longitude);
        },
        (error) => {
          let errorMessage = '';
          if (error.code === error.PERMISSION_DENIED) {
            errorMessage = "User denied the request for location";
          } else if (error.code === error.POSITION_UNAVAILABLE) {
            errorMessage = "Location information is unavailable";
          } else if (error.code === error.TIMEOUT) {
            errorMessage = "The request to get user location timed out";
          } else {
            errorMessage = "An unknown error occurred";
          }

          if (lastPositionMessage) {
            showToast(`${errorMessage}. Using last known location.`);
            sendLocationAndTimeCommand(lastPositionMessage.latitude, lastPositionMessage.longitude);
          } else {
            showToast(errorMessage);
          }
        }
      );
    }

    function displayMainCommands() {
      const mainCommandsElement = document.getElementById('main-commands');
      if (!mainCommandsElement || !settingsData || !settingsData.commands) {
        return;
      }
      const activeCommands = lrUpdateMode
        ? { 'cmd_reset': 'Reboot device' }
        : mainCommands;

      mainCommandsElement.innerHTML = Object.entries(activeCommands).map(([key, label]) => {
        const command = settingsData.commands[key];
        if (!command) {
          return '';
        }
        const isUbloxFix = key === 'cmd_get_ublox_fix';
        const isDisabled = isUbloxFix && ubloxBusyStatus;
        const disabledAttr = isDisabled ? ' disabled' : '';
        const titleAttr = isDisabled ? ' title="UBLOX is busy. Please wait."' : '';
        return `<button id="command-button-${command.id}" onclick="executeCommand('${command.id}')"${disabledAttr}${titleAttr}>${label}</button>`;
      }).join('');

      if (!lrUpdateMode) {
        mainCommandsElement.innerHTML += `
          <button class="hidden-when-no-status" onclick="setLocationAndTime()">Set location & time</button>
          <button class="hidden-when-no-status" onclick="copyDeviceInfo()">Copy device info</button>
        `;
      }
    }

    function log(message, isError = false) {
      const logElement = document.getElementById('log');
      const logEntry = document.createElement('div');
      logEntry.classList.add('log-entry');
      if (isError) {
        logEntry.classList.add('error');
      }
      logEntry.textContent = `[${new Date().toLocaleTimeString("nl-NL")}] ${message}`;
      logElement.appendChild(logEntry);
      logElement.scrollTop = logElement.scrollHeight;
    }

    function autoSelectAndLoadSettings(statusMessage) {
      const settingsDropdown = document.getElementById('settings-dropdown');
      const fwVersion = `v${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}`;

      for (let i = 0; i < settingsDropdown.options.length; i++) {
        if (settingsDropdown.options[i].text.includes(fwVersion)) {
          settingsDropdown.selectedIndex = i;
          loadSelectedSettings();
          break;
        }
      }
    }

    function onDisconnected() {
      log('Disconnected from device');
      if (flashLogState.active) {
        showFlashLogFailure('Connection lost during log download.');
      }
      mapFullscreen = false;
      document.body.classList.remove('map-fullscreen');
      const mapViewToggle = document.getElementById('map-view-toggle');
      if (mapViewToggle) {
        mapViewToggle.textContent = 'Fullscreen';
        mapViewToggle.setAttribute('title', 'Fullscreen map');
      }
      mapTrackState.active = false;
      setMapTracksOverlayVisible(false);
      setUbloxFixOverlayVisible(false);
      ubloxFixPending = false;
      clearUbloxFixTimeout();
      clearUbloxFixCountdown();
      autoLoaded = false;
      setLrUpdateMode(false);
      document.body.classList.remove('connected');
      document.body.classList.remove('has-status');
      document.body.classList.remove('has-settings');
      if (document.body.classList.contains('dfu-active')) {
        const awaiting = window.DfuApp && window.DfuApp.isAwaitingReboot && window.DfuApp.isAwaitingReboot();
        if (awaiting) {
          showToast('Device rebooted. Waiting to reconnect for DFU.');
        } else {
          showToast('Device disconnected. Use Reconnect to continue DFU.');
        }
      }
      if (userRequestedDisconnect) {
        try {
          sessionStorage.removeItem('dfuDeviceInfo');
        } catch (error) {
          console.warn('Failed to clear DFU device info', error);
        }
        userRequestedDisconnect = false;
      }
      lastPositionMessage = null;
      setMapStatus('Waiting for location...');
      if (mapMarker && mapInstance) {
        mapInstance.removeLayer(mapMarker);
      }
      mapMarker = null;
    }

    const connectButton = document.getElementById('connect-button');
    const deviceNameFilterInput = document.getElementById('device-name-filter');

    function parseDeviceNameFilters(value) {
      const rawEntries = String(value || '')
        .split(',')
        .map(entry => entry.trim())
        .filter(entry => entry.length > 0);

      return rawEntries.map(entry => {
        // Be forgiving: treat bare values as prefixes. Use a trailing '*'
        // explicitly as well (e.g., "SP05*").
        const normalized = entry.endsWith('*') ? entry.slice(0, -1).trim() : entry;
        if (!normalized) return null;
        return { namePrefix: normalized };
      }).filter(Boolean);
    }

    async function connectToDevice(selectedDevice, options = {}) {
      const connectLabel = connectButton.textContent;
      try {
        connectButton.disabled = true;
        connectButton.textContent = 'Connecting...';
        userRequestedDisconnect = false;

        device = selectedDevice;
        window.device = device;
        log(`Connecting to ${device && device.name ? device.name : 'device'}...`);
        device.addEventListener('gattserverdisconnected', onDisconnected);
        if (options.reuseConnected && device.gatt && device.gatt.connected) {
          log('Reusing existing GATT connection.');
          server = device.gatt;
        } else {
          log('Opening new GATT connection...');
          server = await device.gatt.connect();
        }
        window.server = server;

        log('Discovering UART service...');
        const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
        txCharacteristic = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e');
        rxCharacteristic = await service.getCharacteristic('6e400002-b5a3-f393-e0a9-e50e24dcca9e');
        window.txCharacteristic = txCharacteristic;
        window.rxCharacteristic = rxCharacteristic;

        log('Enabling notifications...');
        await txCharacteristic.startNotifications();
        txCharacteristic.addEventListener('characteristicvaluechanged', handleNotifications);

        document.body.classList.add('connected');
        log(`Connected to device: ${device.name}`);

        loadAvailableSettings();
        await checkPin(document.getElementById('pincode').value);
      } catch (error) {
        log(`Error: ${error.message}`, true);
      } finally {
        connectButton.textContent = connectLabel;
        connectButton.disabled = false;
      }
    }
    window.connectToDevice = connectToDevice;

    connectButton.addEventListener('click', async function () {
      const manufacturerFilter = {
        manufacturerData: [{ companyIdentifier: 0x0A61 }]
      };
      const nameFilters = parseDeviceNameFilters(deviceNameFilterInput.value);
      const filters = nameFilters.length
        ? nameFilters.map(nameFilter => ({ ...manufacturerFilter, ...nameFilter }))
        : [manufacturerFilter];

      if (nameFilters.length) {
        const filterSummary = nameFilters
          .map(filter => filter.name ? filter.name : `${filter.namePrefix}*`)
          .join(', ');
        log(`Applying device name filters: ${filterSummary}`);
      }

      try {
        const selectedDevice = await navigator.bluetooth.requestDevice({
          filters,
          optionalServices: [
            '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
            '8d53dc1d-1db7-4cd3-868b-8a527460aa84'
          ]
        });
        await connectToDevice(selectedDevice);
      } catch (error) {
        log(`Error: ${error.message}`, true);
      }
    });

    document.getElementById('disconnect-button').addEventListener('click', function () {
      if (device && device.gatt.connected) {
        userRequestedDisconnect = true;
        device.gatt.disconnect();
      }
    });

    async function autoReconnectIfAvailable() {
      if (!navigator.bluetooth || !navigator.bluetooth.getDevices) {
        return;
      }
      let storedInfo = null;
      try {
        const raw = sessionStorage.getItem('dfuDeviceInfo');
        if (raw) {
          storedInfo = JSON.parse(raw);
        }
      } catch (error) {
        storedInfo = null;
      }
      if (!storedInfo || !storedInfo.deviceName) {
        return;
      }
      try {
        const devices = await navigator.bluetooth.getDevices();
        const matching = devices.find(knownDevice => knownDevice.name === storedInfo.deviceName);
        if (matching) {
          log(`Reconnecting to ${matching.name}...`);
          await connectToDevice(matching);
        }
      } catch (error) {
        console.warn('Auto reconnect failed', error);
      }
    }

    autoReconnectIfAvailable();

    async function handleNotifications(event) {
      const value = event.target.value;
      const data = new Uint8Array(value.buffer);

      log(`Raw data received: ${bytesToHex(data)}`);

      const port = data[0];
      try {
        if (tryHandleTrackResponse(data)) {
          return;
        }
        const flashLogPort = settingsData && settingsData.ports ? settingsData.ports.port_flash_log : null;
        if (flashLogPort && port === flashLogPort) {
          handleFlashLogChunk(data);
          return;
        }
        if (port === 31 && data.length >= 5 && data[1] === MSG_CMD_CONFIRM && data[3] === CMD_CHECK_PIN && data[4] === 0x01) {
          log(`PIN OK`);
          await requestStatusMessage();
        } else if (port === 31 && data.length >= 5 && data[1] === MSG_CMD_CONFIRM && data[3] === CMD_FLASH_CLEAR) {
          if (data[4] === 0x01) {
            showToast('All logs erased.');
            setFlashLogStatus('Logs erased');
            requestFlashLogCount();
          } else {
            showToast(`Failed to erase logs (status 0x${data[4].toString(16).padStart(2, '0')}).`);
            setFlashLogStatus('Erase failed');
          }
        } else if (port === 31 && data.length >= 5 && data[1] === MSG_CMD_CONFIRM && data[3] === 0xBB) {
          if (data[4] === 0x01) {
            finishFlashLogCapture('device confirm');
          } else if (flashLogState.active) {
            showFlashLogFailure(`Device returned status 0x${data[4].toString(16).padStart(2, '0')}.`);
          }
        } else if (port === 3) {
          decodeBleValueResponse(data.slice(1));
        } else if (port === 30 && data[1] == VAL_UBLOX_TIME) {
          const timestamp = bytesToSetting(settingsData.values['ublox_time'], data.slice(3));
          log(`Decoded: ublox time = ${timestamp}`);
          const timestampEl = document.getElementById('ublox-timestamp');
          if (timestampEl) {
            timestampEl.textContent = new Date(timestamp * 1000).toLocaleString("nl-NL");
          }
        } else if (port === 18 && data[1] === MSG_TIMESTAMP) {
          const timestamp = new DataView(new Uint8Array(data.slice(3)).buffer).getInt32(0, true)
          const timestampEl = document.getElementById('ublox-timestamp');
          if (timestampEl) {
            timestampEl.textContent = new Date(timestamp * 1000).toLocaleString("nl-NL");
          }
          log(`Decoded: timestamp = ${JSON.stringify(timestamp)}`);
        } else if (port === 31 && data[1] === MSG_LAST_POSITION) {
          lastPositionMessage = decodeLastPositionMessage(data.slice(3));
          const locationEl = document.getElementById('ublox-location');
          if (locationEl) {
            locationEl.innerHTML = `<a href="https://maps.google.com/?q=${lastPositionMessage.latitude},${lastPositionMessage.longitude}" target="_blank">${lastPositionMessage.latitude.toFixed(3)},${lastPositionMessage.longitude.toFixed(3)}</a>`;
          }
          log(`Decoded: last postion = ${JSON.stringify(lastPositionMessage)}`);
          updateMapLocation();
        } else if (port === 4) {
          const statusMessage = decodeStatusMessage(data.slice(1));
          setLrUpdateMode(isLrUpdateFirmware(statusMessage));
          await displayStatusMessage(statusMessage);
          document.body.classList.add('has-status');
          if (!autoLoaded) {
            autoLoaded = true;
            autoSelectAndLoadSettings(statusMessage);
          }
        } else {
          await decodeMessage(data);
        }
      } catch (error) {
        console.error(error);
        log(`Error decoding response: ${error.message}`, true);
      }
    }

    function decodeUbloxFixMessage(bytes) {
      const payload = new Uint8Array(bytes);
      if (payload.length < 30) {
        throw new Error(`UBLOX fix payload too short (${payload.length} bytes)`);
      }
      const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
      const success = view.getUint8(0) !== 0;
      const hot_retry = view.getUint8(1);
      const cold_retry = view.getUint8(2);
      const ttf = view.getUint8(3);
      const latitude = view.getInt32(5, true) / 1e7;
      const longitude = view.getInt32(9, true) / 1e7;
      const altitude = view.getInt32(13, true) / 1000;
      const fix_type = view.getUint8(17);
      const siv = view.getUint8(18);
      const h_acc_est = view.getUint16(19, true);
      const pDOP = view.getUint8(21);
      const fix_timestamp = view.getUint32(22, true);
      const active_tracking = view.getUint8(26) !== 0;

      return {
        altitude,
        cold_retry,
        hot_retry,
        latitude,
        longitude,
        success,
        ttf,
        fix_type,
        siv,
        h_acc_est,
        pDOP,
        fix_timestamp,
        active_tracking,
      };
    }

    function formatUbloxFixValue(value, decimals = null) {
      if (typeof value === 'number' && Number.isFinite(value)) {
        return decimals === null ? String(value) : value.toFixed(decimals);
      }
      return String(value);
    }

    function formatUbloxFixTimestamp(seconds) {
      if (!Number.isFinite(seconds) || seconds <= 0) {
        return 'N/A';
      }
      return new Date(seconds * 1000).toLocaleString("nl-NL");
    }

    function buildUbloxFixRow(label, value, isHtml = false) {
      const safeLabel = escapeHtml(label);
      const safeValue = isHtml ? value : escapeHtml(value);
      return `<div class="ublox-fix-row"><span>${safeLabel}</span><span>${safeValue}</span></div>`;
    }

    function renderUbloxFixResults(result) {
      const hasCoords = Number.isFinite(result.latitude) && Number.isFinite(result.longitude);
      const locationLink = hasCoords
        ? `<a href="https://maps.google.com/?q=${result.latitude},${result.longitude}" target="_blank">${formatUbloxFixValue(result.latitude, 3)},${formatUbloxFixValue(result.longitude, 3)}</a>`
        : 'N/A';

      const rows = [
        buildUbloxFixRow('Success', result.success ? 'Yes' : 'No'),
        buildUbloxFixRow('Location', locationLink, true),
        buildUbloxFixRow('Latitude', hasCoords ? formatUbloxFixValue(result.latitude, 6) : 'N/A'),
        buildUbloxFixRow('Longitude', hasCoords ? formatUbloxFixValue(result.longitude, 6) : 'N/A'),
        buildUbloxFixRow('Altitude (m)', formatUbloxFixValue(result.altitude, 2)),
        buildUbloxFixRow('TTF (s)', result.ttf),
        buildUbloxFixRow('Fix time (s)', result.fix_timestamp),
        buildUbloxFixRow('Fix time (local)', formatUbloxFixTimestamp(result.fix_timestamp)),
        buildUbloxFixRow('Fix type', result.fix_type),
        buildUbloxFixRow('Satellites', result.siv),
        buildUbloxFixRow('HDOP est', result.h_acc_est),
        buildUbloxFixRow('PDOP', result.pDOP),
        buildUbloxFixRow('Cold retry', result.cold_retry),
        buildUbloxFixRow('Hot retry', result.hot_retry),
        buildUbloxFixRow('Active tracking', result.active_tracking ? 'Yes' : 'No'),
      ];
      return rows.join('');
    }

    function setUbloxFixOverlayVisible(visible) {
      const overlay = document.getElementById('ublox-fix-overlay');
      if (!overlay) return;
      overlay.classList.toggle('hidden', !visible);
    }

    function showUbloxFixOverlayWaiting(timeoutSeconds = null) {
      const overlay = document.getElementById('ublox-fix-overlay');
      const spinner = document.getElementById('ublox-fix-spinner');
      const title = document.getElementById('ublox-fix-title');
      const results = document.getElementById('ublox-fix-results');
      const map = document.getElementById('ublox-fix-map');
      const raw = document.getElementById('ublox-fix-raw');
      const retryButton = document.getElementById('ublox-fix-retry');
      const cancelButton = document.getElementById('ublox-fix-cancel');
      const okButton = document.getElementById('ublox-fix-ok');
      if (!overlay || !spinner || !title || !results || !map || !raw || !retryButton || !cancelButton || !okButton) return;

      title.textContent = 'Waiting for UBLOX fix...';
      spinner.classList.remove('hidden');
      results.classList.add('hidden');
      map.classList.add('hidden');
      raw.classList.add('hidden');
      retryButton.classList.add('hidden');
      cancelButton.classList.add('hidden');
      okButton.classList.add('hidden');
      if (Number.isFinite(timeoutSeconds) && timeoutSeconds > 0) {
        const rounded = Math.round(timeoutSeconds);
        results.innerHTML = [
          buildUbloxFixRow('Max wait', `${rounded} seconds`),
          buildUbloxFixRow('Time remaining', `${rounded} seconds`)
        ].join('');
        results.classList.remove('hidden');
      }
      setUbloxFixOverlayVisible(true);
    }

    function showUbloxFixOverlayTimeout() {
      const overlay = document.getElementById('ublox-fix-overlay');
      const spinner = document.getElementById('ublox-fix-spinner');
      const title = document.getElementById('ublox-fix-title');
      const results = document.getElementById('ublox-fix-results');
      const map = document.getElementById('ublox-fix-map');
      const raw = document.getElementById('ublox-fix-raw');
      const retryButton = document.getElementById('ublox-fix-retry');
      const cancelButton = document.getElementById('ublox-fix-cancel');
      const okButton = document.getElementById('ublox-fix-ok');
      if (!overlay || !spinner || !title || !results || !map || !raw || !retryButton || !cancelButton || !okButton) return;

      title.textContent = 'UBLOX fix timed out.';
      spinner.classList.add('hidden');
      results.innerHTML = buildUbloxFixRow('Status', 'Timed out');
      results.classList.remove('hidden');
      map.classList.add('hidden');
      raw.classList.add('hidden');
      retryButton.classList.remove('hidden');
      cancelButton.classList.remove('hidden');
      okButton.classList.add('hidden');
      setUbloxFixOverlayVisible(true);
    }

    function clearUbloxFixTimeout() {
      if (ubloxFixTimeoutId) {
        clearTimeout(ubloxFixTimeoutId);
        ubloxFixTimeoutId = null;
      }
    }

    function clearUbloxFixCountdown() {
      if (ubloxFixCountdownId) {
        clearInterval(ubloxFixCountdownId);
        ubloxFixCountdownId = null;
      }
    }

    function setFlashLogStatus(message) {
      const statusEl = document.getElementById('flash-log-status');
      if (statusEl) {
        statusEl.textContent = message;
      }
    }

    function updateFlashLogCount(value) {
      const countEl = document.getElementById('flash-log-count');
      if (countEl) {
        countEl.textContent = Number.isFinite(value) ? String(value) : 'N/A';
      }
      flashLogCountTotal = Number.isFinite(value) ? Number(value) : null;
      setFlashLogStatus('Updated');
    }

    function requestFlashLogCount() {
      const flashValue = settingsData && settingsData.values ? settingsData.values.flash_nr_msg : null;
      if (!flashValue) {
        setFlashLogStatus('Flash log count not available in this firmware.');
        return;
      }
      if (!document.body.classList.contains('connected') || !rxCharacteristic) {
        setFlashLogStatus('Connect to a device to read flash log count.');
        return;
      }
      setFlashLogStatus('Requesting flash log count...');
      requestBleValue(flashValue.id, CMD_SEND_SINGLE_VAL);
    }

    function populateFlashLogTypeOptions() {
      const select = document.getElementById('flash-log-type-select');
      if (!select) {
        return;
      }

      const ports = settingsData && settingsData.ports ? settingsData.ports : null;
      const messages = settingsData && settingsData.messages ? settingsData.messages : null;
      if (!ports || !messages) {
        select.innerHTML = '<option value="">Message type list unavailable</option>';
        return;
      }

      const options = Array.from(new Set(
        Object.values(messages)
          .map((message) => message.port)
          .filter((portName) => typeof portName === 'string' && Number.isFinite(ports[portName]))
      ))
        .map((portName) => ({
          name: portName.replace(/^port_/, ''),
          port: ports[portName]
        }))
        .sort((a, b) => a.port - b.port);

      if (!options.length) {
        select.innerHTML = '<option value="">No message types found</option>';
        return;
      }

      select.innerHTML = options
        .map((option) => `<option value="${option.port}">${option.name} - port ${option.port}</option>`)
        .join('');
    }

    function downloadFlashLogsByType() {
      if (flashLogState.active) {
        showToast('A log download is already in progress.');
        return;
      }
      const flashCommand = settingsData && settingsData.commands ? settingsData.commands.cmd_flash_get_all : null;
      if (!flashCommand) {
        showToast('Flash log command not available in this firmware.');
        return;
      }
      if (!document.body.classList.contains('connected') || !rxCharacteristic) {
        showToast('Connect to a device first.');
        return;
      }

      const select = document.getElementById('flash-log-type-select');
      if (!select || !select.value) {
        showToast('Select a message type first.');
        return;
      }

      const selectedPort = Number.parseInt(select.value, 10);
      if (!Number.isFinite(selectedPort)) {
        showToast('Invalid message type selection.');
        return;
      }

      const selectedLabel = select.options[select.selectedIndex]?.text || `port ${selectedPort}`;
      startFlashLogCapture({
        logTypeLabel: selectedLabel,
        requestMode: 'type',
        requestedPort: selectedPort,
        expectedTotal: null
      });
      executeBleCommand([0x20, parseInt(flashCommand.id, 16), 0x01, selectedPort]);
    }

    function cancelFlashLogDownload() {
      if (flashLogState.active) {
        clearFlashLogInactivityTimeout();
        flashLogState.active = false;
        log('Flash log download cancelled by user.');
      }
      setFlashLogOverlayVisible(false);
    }

    function retryFlashLogDownload() {
      if (flashLogState.active) {
        showToast('A log download is already in progress.');
        return;
      }
      const request = flashLogState.lastRequest;
      if (!request) {
        showToast('No previous log download to retry.');
        return;
      }
      const flashCommand = settingsData && settingsData.commands ? settingsData.commands.cmd_flash_get_all : null;
      if (!flashCommand) {
        showToast('Flash log command not available in this firmware.');
        return;
      }
      if (!document.body.classList.contains('connected') || !rxCharacteristic) {
        showToast('Connect to a device first.');
        return;
      }

      startFlashLogCapture(request);
      executeBleCommand([0x20, parseInt(flashCommand.id, 16), 0x01, request.requestedPort]);
    }

    function setFlashLogEraseConfirmVisible(visible) {
      const overlay = document.getElementById('flash-log-erase-confirm-overlay');
      if (!overlay) {
        return;
      }
      overlay.classList.toggle('hidden', !visible);
    }

    function requestEraseAllLogs() {
      if (flashLogState.active) {
        showToast('Cancel the current log download first.');
        return;
      }
      const flashClear = settingsData && settingsData.commands ? settingsData.commands.cmd_flash_clear : null;
      if (!flashClear) {
        showToast('Flash clear command not available in this firmware.');
        return;
      }
      if (!document.body.classList.contains('connected') || !rxCharacteristic) {
        showToast('Connect to a device first.');
        return;
      }
      setFlashLogEraseConfirmVisible(true);
    }

    function eraseAllLogs() {
      const flashClear = settingsData && settingsData.commands ? settingsData.commands.cmd_flash_clear : null;
      if (!flashClear) {
        showToast('Flash clear command not available in this firmware.');
        setFlashLogEraseConfirmVisible(false);
        return;
      }
      executeCommand(flashClear.id);
      setFlashLogEraseConfirmVisible(false);
      setFlashLogOverlayVisible(false);
      setFlashLogStatus('Erasing logs...');
    }

    function getColdFixTimeoutSeconds() {
      const setting = settingsData && settingsData.settings ? settingsData.settings.cold_fix_timeout : null;
      if (!setting) {
        return 0;
      }
      const currentValue = getInputValue(setting.id);
      const parsed = Number.parseFloat(currentValue);
      if (Number.isFinite(parsed)) {
        return parsed;
      }
      const fallback = Number.parseFloat(setting.default);
      return Number.isFinite(fallback) ? fallback : 0;
    }

    function scheduleUbloxFixTimeout() {
      clearUbloxFixTimeout();
      clearUbloxFixCountdown();
      const timeoutSeconds = getColdFixTimeoutSeconds() + 10;
      const timeoutMs = Math.max(10, Math.round(timeoutSeconds * 1000));
      showUbloxFixOverlayWaiting(timeoutSeconds);
      startUbloxFixCountdown(Math.max(1, Math.round(timeoutSeconds)));
      ubloxFixTimeoutId = setTimeout(() => {
        if (!ubloxFixPending) {
          return;
        }
        ubloxFixPending = false;
        clearUbloxFixCountdown();
        showUbloxFixOverlayTimeout();
      }, timeoutMs);
    }

    function startUbloxFixCountdown(totalSeconds) {
      const results = document.getElementById('ublox-fix-results');
      if (!results || !Number.isFinite(totalSeconds) || totalSeconds <= 0) {
        return;
      }
      let remaining = totalSeconds;
      const updateRow = () => {
        const rows = results.querySelectorAll('.ublox-fix-row');
        if (!rows || rows.length < 2) return;
        const valueEl = rows[1].querySelector('span:last-child');
        if (valueEl) {
          valueEl.textContent = `${Math.max(0, remaining)} seconds`;
        }
      };
      updateRow();
      ubloxFixCountdownId = setInterval(() => {
        if (!ubloxFixPending) {
          clearUbloxFixCountdown();
          return;
        }
        remaining -= 1;
        updateRow();
        if (remaining <= 0) {
          clearUbloxFixCountdown();
        }
      }, 1000);
    }

    async function updateUbloxFixMap(latitude, longitude) {
      const mapEl = document.getElementById('ublox-fix-map');
      if (!mapEl) return;
      if (!navigator.onLine) {
        mapEl.classList.add('hidden');
        return;
      }
      try {
        await loadLeafletIfNeeded();
        mapEl.classList.remove('hidden');
        if (!ubloxFixMapInstance) {
          ubloxFixMapInstance = L.map(mapEl, {
            zoomControl: true,
            attributionControl: false,
          }).setView([latitude, longitude], 14);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; OpenStreetMap'
          }).addTo(ubloxFixMapInstance);
        }
        if (!ubloxFixMapMarker) {
          ubloxFixMapMarker = L.marker([latitude, longitude]).addTo(ubloxFixMapInstance);
        } else {
          ubloxFixMapMarker.setLatLng([latitude, longitude]);
        }
        ubloxFixMapInstance.setView([latitude, longitude], 14, { animate: false });
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            if (ubloxFixMapInstance) {
              ubloxFixMapInstance.invalidateSize();
            }
          });
        });
      } catch (error) {
        console.warn('Failed to load UBLOX map', error);
        mapEl.classList.add('hidden');
      }
    }

    function showUbloxFixOverlayResult(result, rawHex) {
      const overlay = document.getElementById('ublox-fix-overlay');
      const spinner = document.getElementById('ublox-fix-spinner');
      const title = document.getElementById('ublox-fix-title');
      const results = document.getElementById('ublox-fix-results');
      const map = document.getElementById('ublox-fix-map');
      const raw = document.getElementById('ublox-fix-raw');
      const retryButton = document.getElementById('ublox-fix-retry');
      const cancelButton = document.getElementById('ublox-fix-cancel');
      const okButton = document.getElementById('ublox-fix-ok');
      if (!overlay || !spinner || !title || !results || !map || !raw || !retryButton || !cancelButton || !okButton) return;

      const noSignalAbort = result && !result.success && Number.isFinite(result.ttf) && result.ttf < 35;
      const isSuccess = Boolean(result && result.success);
      title.textContent = isSuccess ? 'UBLOX fix completed.' : 'UBLOX fix completed (no fix).';
      spinner.classList.add('hidden');
      if (noSignalAbort) {
        results.innerHTML = buildUbloxFixRow('No GPS signal', 'Fix stopped early to save power.');
      } else {
        results.innerHTML = result ? renderUbloxFixResults(result) : '';
      }
      results.classList.remove('hidden');
      raw.textContent = rawHex ? `Raw: ${rawHex}` : '';
      raw.classList.toggle('hidden', !rawHex);
      retryButton.classList.toggle('hidden', isSuccess);
      cancelButton.classList.toggle('hidden', isSuccess);
      okButton.classList.toggle('hidden', !isSuccess);
      setUbloxFixOverlayVisible(true);

      if (isSuccess && Number.isFinite(result.latitude) && Number.isFinite(result.longitude)) {
        updateUbloxFixMap(result.latitude, result.longitude);
      } else {
        map.classList.add('hidden');
      }
    }

    function handleUbloxFixResponse(rawBytes, valueBytes) {
      const rawHex = bytesToHex(rawBytes);
      try {
        const result = decodeUbloxFixMessage(valueBytes);
        showUbloxFixOverlayResult(result, rawHex);
      } catch (error) {
        showUbloxFixOverlayResult(null, rawHex);
        log(`Failed to decode UBLOX fix response: ${error.message}`, true);
      }
      ubloxFixPending = false;
      clearUbloxFixTimeout();
      clearUbloxFixCountdown();
    }

    function decodeLastPositionMessage(bytes) {
      let val = (bytes[3] << 24) | (bytes[2] << 16) | (bytes[1] << 8) | bytes[0];
      const longitude = val / 10000000; // gps latitude, units: 
      val = (bytes[7] << 24) | (bytes[6] << 16) | (bytes[5] << 8) | bytes[4];
      const latitude = val / 10000000; // gps longitude, units: 
      val = (bytes[11] << 24) | (bytes[10] << 16) | (bytes[9] << 8) | bytes[8];
      const altitude = val / 1000; // gps altitude, units: m
      val = (bytes[15] << 24) | (bytes[14] << 16) | (bytes[13] << 8) | bytes[12];
      const timestamp = val;
      return { latitude, longitude, altitude, timestamp };
    }

    async function decodeMessage(data) {
      const port = data[0];
      if (!settingsData) {
        log(`No settings data available to decode message for port: ${port}`);
        return;
      }

      const portName = Object.keys(settingsData.ports).find(key => settingsData.ports[key] === port);
      if (portName) {
        if (portName === 'port_values') {
          decodeBleValueResponse(data.slice(1));
          return;
        }
        const id = data[1];
        const message = Object.entries(settingsData.messages).find(([key, msg]) => msg.port === portName && msg.id.toUpperCase() === `0x${id.toString(16)}`.toUpperCase());
        if (message) {
          const [key, msg] = message;
          const valueBytes = data.slice(3, 3 + msg.length);

          if (key === 'msg_cmd_confirm' && valueBytes[0] === CMD_SET_LOCATION_AND_TIME) {
            // Updated time and position, refresh time and position
            await requestStatusMessage();
          } else if (key === 'msg_ublox_location') {
            if (ubloxFixPending) {
              const rawBytes = data.slice(1);
              handleUbloxFixResponse(rawBytes, valueBytes);
            } else {
              log(`Decoded message: ${key} = ${bytesToSetting(msg, valueBytes)}`);
            }
          } else {
            log(`Decoded message: ${key} = ${bytesToSetting(msg, valueBytes)}`);
          }
        } else {
          throw new Error(`No message found for port: ${portName} and id: 0x${id.toString(16)}`);
        }
      } else {
        throw new Error('No decoder available for port: ' + port);
      }
    }

    function decodeBleValueResponse(bytes) {
      for (let i = 0; i < bytes.length;) {
        const id = bytes[i++];
        const len = bytes[i++];
        const valueBytes = bytes.slice(i, i + len);

        const [key, setting] = getById(id);
        let value = bytesToSetting(setting, valueBytes);
        log(`Decoded setting response: ${key} = ${value}`);
        const inputContainer = document.getElementById(`input-container-${setting.id}`);
        if (inputContainer) {
          updateSettingDisplay(setting.id, value);
        }
        if (key === 'flash_nr_msg') {
          updateFlashLogCount(value);
        }
        i += len;
      }
    }

    function arraysEqual(arr1, arr2) {
      // Check if lengths are different
      if (arr1.length !== arr2.length) {
        return false;
      }

      // Check if all elements are equal
      return arr1.every((element, index) => element === arr2[index]);
    }

    function isValueNotDefault(settingId, value) {
      const [key, valueMeta] = getById(settingId);
      if (valueMeta.conversion === 'byte_array') {
        return !arraysEqual(stringToUint8Array(value, valueMeta.length), stringToUint8Array(stripBytes(valueMeta.default), valueMeta.length));
      }
      return value !== valueMeta.default;
    }

    function updateSettingDisplay(settingId, value) {
      setInputValue(settingId, value);

      const rowElement = document.getElementById(`setting-${settingId}`);
      if (rowElement) {
        rowElement.classList.remove('disabled');
        if (isValueNotDefault(settingId, value)) {
          rowElement.classList.add('value-not-default');
        } else {
          rowElement.classList.remove('value-not-default');
        }
      }
    }

    async function requestBleValue(id, cmd) {
      if (typeof id === 'string' || id instanceof String) {
        id = parseInt(id, 16);
      }

      return executeBleCommand([0x20, cmd, 0x01, id]);
    }

    async function executeCommand(cmd) {
      if (typeof cmd === 'string' || cmd instanceof String) {
        cmd = parseInt(cmd, 16);
      }

      const [key, commandMeta] = getById(cmd);
      if (key === 'cmd_get_ublox_fix' && ubloxBusyStatus) {
        showToast('UBLOX is busy. Please wait before starting another fix.');
        return;
      }
      if (key === 'cmd_flash_get_all' && flashLogState.active) {
        showToast('A log download is already in progress.');
        return;
      }
      showToast(`Executing command: ${key}`);
      if (key === 'cmd_get_ublox_fix') {
        ubloxFixPending = true;
        scheduleUbloxFixTimeout();
      }
      if (key === 'cmd_flash_get_all') {
        const expectedTotal = Number.isFinite(flashLogCountTotal) && flashLogCountTotal >= 0 ? flashLogCountTotal : null;
        startFlashLogCapture({
          logTypeLabel: 'all',
          requestMode: 'all',
          requestedPort: 0,
          expectedTotal
        });
      }
        if (commandMeta && commandMeta.length === 1) {
          const selectEl = document.getElementById(`command-select-${commandMeta.id}`);
          const inputEl = document.getElementById(`command-input-${commandMeta.id}`);
          let value = 0;
          if (selectEl) {
          const selected = selectEl.value;
          if (selected && selected.startsWith('0x')) {
            value = parseInt(selected, 16);
          } else {
            value = parseInt(selected, 10);
          }
          } else if (inputEl) {
          const rawValue = inputEl.value.trim();
          const format = inputEl.getAttribute('data-format') || 'uint8';
          if (rawValue.length === 0) {
            value = 0;
          } else if (format === 'hex8') {
            const cleaned = rawValue.replace(/^0x/i, '');
            const parsed = parseInt(cleaned, 16);
            if (Number.isNaN(parsed)) {
              showToast('Invalid hex value');
              return;
            }
            value = parsed;
          } else {
            const parsed = parseInt(rawValue, 10);
            if (Number.isNaN(parsed)) {
              showToast('Invalid numeric value');
              return;
            }
            value = parsed;
          }
        } else if (commandMeta && commandMeta.value !== undefined) {
          value = commandMeta.value;
        }
        return executeBleCommand([0x20, cmd, 0x01, value]);
      }
      return executeBleCommand([0x20, cmd, 0x00]);
    }

    async function requestStatusMessage() {
      return executeBleCommand([0x20, CMD_STATUS, 0x00])
    }

    const flashLogOkButton = document.getElementById('flash-log-ok');
    if (flashLogOkButton) {
      flashLogOkButton.addEventListener('click', () => {
        setFlashLogOverlayVisible(false);
      });
    }

    const mapTracksOkButton = document.getElementById('map-tracks-ok');
    if (mapTracksOkButton) {
      mapTracksOkButton.addEventListener('click', () => {
        setMapTracksOverlayVisible(false);
      });
    }

    const flashLogCancelButton = document.getElementById('flash-log-cancel');
    if (flashLogCancelButton) {
      flashLogCancelButton.addEventListener('click', () => {
        cancelFlashLogDownload();
      });
    }

    const flashLogRetryButton = document.getElementById('flash-log-retry');
    if (flashLogRetryButton) {
      flashLogRetryButton.addEventListener('click', () => {
        retryFlashLogDownload();
      });
    }

    const flashLogEraseButton = document.getElementById('flash-log-erase');
    if (flashLogEraseButton) {
      flashLogEraseButton.addEventListener('click', () => {
        requestEraseAllLogs();
      });
    }

    const flashLogEraseCancelButton = document.getElementById('flash-log-erase-cancel');
    if (flashLogEraseCancelButton) {
      flashLogEraseCancelButton.addEventListener('click', () => {
        setFlashLogEraseConfirmVisible(false);
      });
    }

    const flashLogEraseConfirmButton = document.getElementById('flash-log-erase-confirm');
    if (flashLogEraseConfirmButton) {
      flashLogEraseConfirmButton.addEventListener('click', () => {
        eraseAllLogs();
      });
    }

    const ubloxFixOkButton = document.getElementById('ublox-fix-ok');
    if (ubloxFixOkButton) {
      ubloxFixOkButton.addEventListener('click', () => {
        setUbloxFixOverlayVisible(false);
        ubloxFixPending = false;
        clearUbloxFixTimeout();
        clearUbloxFixCountdown();
      });
    }

    const ubloxFixRetryButton = document.getElementById('ublox-fix-retry');
    if (ubloxFixRetryButton) {
      ubloxFixRetryButton.addEventListener('click', () => {
        const command = settingsData && settingsData.commands ? settingsData.commands.cmd_get_ublox_fix : null;
        if (!command) {
          showToast('UBLOX fix command not available.');
          return;
        }
        ubloxFixPending = true;
        executeCommand(command.id);
      });
    }

    const ubloxFixCancelButton = document.getElementById('ublox-fix-cancel');
    if (ubloxFixCancelButton) {
      ubloxFixCancelButton.addEventListener('click', () => {
        setUbloxFixOverlayVisible(false);
        ubloxFixPending = false;
        clearUbloxFixTimeout();
        clearUbloxFixCountdown();
      });
    }

    async function checkPin(pin_in) {
      // add zeros to each number in PIN ("1234" -> "01020304")
      let pin_out = "0" + pin_in.split("").join("0");
      // add zeros to the end (to have 16 byte data length)
      pin_out = pin_out + "000000000000000000000000";
      return executeBleCommand([0x20, CMD_CHECK_PIN, 16, ...stringToUint8Array(pin_out, 16)]);
    }

    async function requestAllSettings() {
      return executeBleCommand([0x20, CMD_SEND_ALL_SETTINGS, 0x00])
    }

    async function writeGattValue(characteristic, buffer) {
      if (characteristic.writeValueWithResponse) {
        return characteristic.writeValueWithResponse(buffer);
      }
      if (characteristic.writeValueWithoutResponse) {
        return characteristic.writeValueWithoutResponse(buffer);
      }
      return characteristic.writeValue(buffer);
    }

    async function executeBleCommand(command) {
      log(`Sending command ${bytesToHex(command)}`);

      const commandBuffer = new Uint8Array(command).buffer;
      try {
        await writeGattValue(rxCharacteristic, commandBuffer);
      } catch (error) {
        log(`Error sending command: ${error.message}`, true);
      }
    }

    async function fetchAllSettings() {
      await requestAllSettings();
    }

    async function updateBleSetting(settingId, newValue) {
      const [settingKey, setting] = getById(settingId);

      let valueBytes = settingToBytes(settingKey, setting, newValue);

      const length = valueBytes.length;
      const command = [0x03, parseInt(settingId, 16), length, ...valueBytes];
      const commandBuffer = new Uint8Array(command).buffer;

      log(`Sending update for ${settingKey} (ID: ${settingId}) with value: ${newValue}`);

      try {
        await writeGattValue(rxCharacteristic, commandBuffer);
        log(`Value updated successfully for ${settingKey} (ID: ${settingId})`);
      } catch (error) {
        log(`Error sending update for ${settingKey}: ${error.message}`, true);
        throw error;
      }
    }

    async function updateSetting(settingId) {
      const rowElement = document.getElementById(`setting-${settingId}`);
      try {
        rowElement.classList.add('disabled');
        await updateBleSetting(settingId, getInputValue(settingId));
        await sleep(1000);
        await requestBleValue(settingId, CMD_SINGLE_SETTING);
      } finally {
        rowElement.classList.remove('disabled');
      }
    }
  </script>
</body>

</html>
