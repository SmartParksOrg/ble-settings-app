<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenCollar Edge BLE Web Connect</title>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(reg => console.log('Service Worker registered:', reg))
        .catch(err => console.error('Service Worker registration failed:', err));
    }
  </script>
  <link rel="stylesheet" href="style.css" />
  <link rel="manifest" href="manifest.json">
  <script src="functions.js"></script>
</head>

<body>
  <div id="header-section" class="page-section">
    <div class="brand">
      <img src="assets/smart-parks-logo.png" alt="Smart Parks" class="brand-logo" />
      <div class="brand-title">
        <span class="brand-name">Smart Parks</span>
        <span class="brand-subtitle">OpenCollar Edge BLE Web Connect</span>
      </div>
    </div>
    <div class="controls">
      <div style="display: flex; justify-content: space-between;">
        <button id="disconnect-button" class="hidden-when-disconnected">Disconnect</button>
        <div class="button-cluster">
          <div class="hidden-when-no-settings">
            <button id="export-button" class="dfu-hide" onclick="exportToJson()">Export</button>
            <input type="file" id="import-file" onchange="importFromJson()" style="display: none;" />
          </div>
          <button id="dfu-button" class="hidden-when-disconnected dfu-hide scan-button" onclick="openDfuPage()">DFU</button>
          <button id="dfu-back-top" class="secondary dfu-only">Back</button>
        </div>
      </div>
      <div class="hidden-when-connected">
        <section class="section section-card scan-card">
          <div class="section-card-title"><span class="icon ble-scan" aria-hidden="true"></span>Scan</div>
          <div class="section-card-body">
            <div class="primary-actions">
              <button id="connect-button" class="scan-button">Scan</button>
            </div>
            <details class="section section-card scan-settings-card">
              <summary class="section-card-title"><span class="icon ble-scan" aria-hidden="true"></span>Scan settings</summary>
              <div class="section-card-body">
                <label class="scan-settings-label" for="device-name-filter">
                  Device name filter (comma-separated prefixes):
                  <input
                    id="device-name-filter"
                    type="text"
                    class="scan-filter-input"
                    placeholder="e.g. SP05, SP06"
                    autocomplete="off"
                    spellcheck="false"
                  />
                </label>
                <label class="scan-settings-label pin-row" id="pin-label">
                  Device PIN:
                  <input
                    name="pincode"
                    id="pincode"
                    type="text"
                    class="pincode"
                    value="0000"
                    inputmode="numeric"
                    maxlength="4"
                  />
                </label>
              </div>
            </details>
          </div>
        </section>
        <section class="section section-card composer-card">
          <div class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Composer</div>
          <div class="section-card-body">
            <div class="composer-actions">
              <a class="button composer-button" href="composer.html">Composer</a>
            </div>
          </div>
        </section>
      </div>
      <div id="settings-selection" class="hidden-when-disconnected">
        <select id="settings-dropdown" onchange="loadSelectedSettings()"></select>
      </div>
      <div id="container">
        <div class="section hidden-when-no-status" id="status-message"></div>
        <div class="section hidden-when-no-settings" id="main-commands"></div>
      </div>

      <div id="dfu-container" class="hidden">
        <div id="dfu-connection-status" class="dfu-connection-status">Not connected</div>
      </div>
    </div>
  </div>

  <div id="settings-area" class="settings-section page-section hidden-when-no-settings">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon hw-version" aria-hidden="true"></span>Settings</summary>
      <div class="section-card-body">
        <div id="search" class="search">
          <input type="text" id="settings-search" placeholder="Search settings..." oninput="filterSettings()">
          <label>
            <input type="checkbox" id="non-default-checkbox" onchange="filterSettings()"> Hide default settings
          </label>
        </div>
        <div id="settings-progress">
          <div></div>
        </div>
        <button id="import-button" class="section-action" onclick="document.getElementById('import-file').click();">Import settings</button>
        <div id="settings-section"></div>
      </div>
    </details>
  </div>

  <div id="other-commands" class="commands-section page-section hidden-when-no-settings">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Commands</summary>
      <div class="section-card-body">
        <div id="commands-buttons-section"></div>
      </div>
    </details>
  </div>

  <div id="map-area" class="map-section page-section hidden-when-no-status">
    <details class="section section-card">
      <summary class="section-card-title"><span class="icon ublox-location" aria-hidden="true"></span>Map</summary>
      <div class="section-card-body">
        <div id="map-status" class="map-status">Waiting for location...</div>
        <div class="map-frame">
          <div id="device-map" class="map-canvas"></div>
          <div id="map-overlay" class="map-overlay hidden">Offline: map unavailable</div>
        </div>
      </div>
    </details>
  </div>

  <nav class="bottom-nav hidden-when-disconnected dfu-keep-visible" aria-label="Primary">
    <a href="#header-section" class="nav-logo" aria-label="Smart Parks">
      <img src="assets/smart-parks-logo.png" alt="Smart Parks" />
    </a>
    <button type="button" class="dfu-only dfu-only-nav" onclick="toggleDfuView(false)" aria-label="Home" title="Home"><span class="icon house" aria-hidden="true"></span></button>
    <a href="#header-section" class="dfu-hide-nav" aria-label="Status" title="Status"><span class="icon square-poll-horizontal" aria-hidden="true"></span></a>
    <a href="#settings-area" class="dfu-hide-nav lr-update-hide" aria-label="Settings" title="Settings"><span class="icon hw-version" aria-hidden="true"></span></a>
    <a href="#other-commands" class="dfu-hide-nav lr-update-hide" aria-label="Commands" title="Commands"><span class="icon messages" aria-hidden="true"></span></a>
    <a href="#map-area" class="dfu-hide-nav lr-update-hide" aria-label="Map" title="Map"><span class="icon ublox-location" aria-hidden="true"></span></a>
    <button type="button" onclick="toggleLog()" aria-label="Log" title="Log"><span class="icon toggle-log" aria-hidden="true"></span></button>
  </nav>

  <div class="log-footer hidden-when-disconnected dfu-keep-visible" id="logFooter">
    <div class="log-header" onclick="toggleLog()">
      <span>Log</span>
      <span class="icon close"></span>
    </div>
    <div class="log-content" id="log"></div>
  </div>

  <div id="import-preview-overlay" class="import-preview-overlay hidden" role="dialog" aria-modal="true"
    aria-labelledby="import-preview-title">
    <div class="import-preview-dialog">
      <div class="import-preview-header">
        <h3 id="import-preview-title">Import preview</h3>
        <p id="import-preview-subtitle"></p>
      </div>
      <div class="import-preview-body">
        <label class="import-preview-toggle">
          <input type="checkbox" id="import-preview-changed-only" checked>
          Show changed only
        </label>
        <table class="import-preview-table">
          <thead>
            <tr>
              <th>Setting</th>
              <th>Current</th>
              <th>New</th>
            </tr>
          </thead>
          <tbody id="import-preview-rows"></tbody>
        </table>
      </div>
      <div class="import-preview-footer">
        <button id="import-preview-cancel" class="secondary" type="button">Cancel</button>
        <button id="import-preview-confirm" type="button">Import</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <div id="dfu-warning-overlay" class="dfu-waiting-overlay hidden">
    <div class="dfu-waiting-card">
      <div class="dfu-waiting-text">Warning: The DFU feature is still in development and should not be used.</div>
      <div class="dfu-confirmation-actions">
        <button id="dfu-warning-cancel" class="secondary" type="button">Cancel</button>
        <button id="dfu-warning-proceed" type="button">Proceed</button>
      </div>
    </div>
  </div>

  <div id="dfu-section" class="page-section hidden">
    <div id="dfu-waiting-overlay" class="dfu-waiting-overlay hidden">
      <div class="dfu-waiting-card">
        <div id="dfu-waiting-spinner" class="dfu-spinner"></div>
        <div id="dfu-waiting-text" class="dfu-waiting-text">Device is rebooting. Reconnect will be enabled shortly.</div>
        <div id="dfu-waiting-countdown" class="dfu-waiting-countdown"></div>
        <button id="dfu-waiting-scan" type="button" class="primary" disabled>Scan and Reconnect</button>
        <button id="dfu-waiting-continue" type="button" class="primary hidden">Go to device</button>
      </div>
    </div>
    <section class="section section-card dfu-card">
      <div class="section-card-title"><span class="icon hw-version" aria-hidden="true"></span>Connected device</div>
      <div class="section-card-body">
        <div class="dfu-device-grid">
          <div>
            <div class="dfu-label">Device</div>
            <div id="dfu-device-name" class="dfu-value">Unknown</div>
          </div>
          <div>
            <div class="dfu-label">Hardware</div>
            <div id="dfu-device-hw" class="dfu-value">Unknown</div>
          </div>
          <div>
            <div class="dfu-label">Firmware</div>
            <div id="dfu-device-fw" class="dfu-value">Unknown</div>
          </div>
          <div>
            <div class="dfu-label">Last status</div>
            <div id="dfu-device-updated" class="dfu-value">Not available</div>
          </div>
        </div>
        <div id="dfu-device-warning" class="dfu-warning hidden">
          Device details are missing. Connect to a device and wait for the status to load.
        </div>
      </div>
    </section>

    <section class="section section-card dfu-card">
      <div class="section-card-title"><span class="icon messages" aria-hidden="true"></span>Step 1: Select DFU file</div>
      <div class="section-card-body">
        <div class="dfu-file-picker">
          <input type="file" id="dfu-file" class="dfu-file-input" accept=".bin,.zip" />
          <label for="dfu-file" class="button dfu-file-button">Select DFU file</label>
          <div class="dfu-file-hint">.bin or .zip</div>
        </div>
        <div id="dfu-file-status" class="dfu-file-status">No file selected.</div>
        <div id="dfu-check-status" class="dfu-check-status">Waiting for file selection.</div>
        <div id="dfu-file-match" class="dfu-file-match hidden"></div>
        <div id="dfu-confirmation" class="dfu-confirmation hidden">
          <div class="dfu-confirmation-text">File checked. Do you want to continue with DFU?</div>
          <div class="dfu-confirmation-actions">
            <button id="dfu-confirm-cancel" class="secondary" type="button">Cancel</button>
            <button id="dfu-confirm-proceed" type="button">Proceed</button>
          </div>
        </div>
      </div>
    </section>

    <section class="section section-card dfu-card hidden" id="dfu-upload-section">
      <div class="section-card-title"><span class="icon ble-scan" aria-hidden="true"></span>Step 2: Upload firmware</div>
      <div class="section-card-body">
        <div class="dfu-upload-status">
          <div class="dfu-upload-status-title">Upload status</div>
          <ul class="dfu-upload-status-list" id="dfu-upload-status-list">
            <li data-step="file"><span class="status-label">File selected</span><span class="status-detail"></span></li>
            <li data-step="start"><span class="status-label">Upload started</span><span class="status-detail"></span></li>
            <li data-step="ack"><span class="status-label">Chunk acknowledged</span><span class="status-detail"></span></li>
            <li data-step="finish"><span class="status-label">Upload finished</span><span class="status-detail"></span></li>
            <li data-step="state"><span class="status-label">Image state checked</span><span class="status-detail"></span></li>
            <li data-step="test"><span class="status-label">Marked for test</span><span class="status-detail"></span></li>
            <li data-step="reboot"><span class="status-label">Device rebooted</span><span class="status-detail"></span></li>
            <li data-step="reconnect"><span class="status-label">Reconnected</span><span class="status-detail"></span></li>
            <li data-step="verify"><span class="status-label">Verified active</span><span class="status-detail"></span></li>
            <li data-step="confirm"><span class="status-label">Confirmed</span><span class="status-detail"></span></li>
          </ul>
        </div>
        <div class="dfu-upload-actions">
          <button id="dfu-upload" disabled>Start DFU upload</button>
          <button id="dfu-cancel" class="secondary" disabled>Cancel</button>
          <button id="dfu-finish" class="secondary">Finish DFU</button>
        </div>
        <div class="dfu-upload-settings">
          <label class="dfu-upload-setting">
            MTU budget (bytes)
            <input id="dfu-upload-mtu" type="number" min="80" step="8" value="240" />
          </label>
          <label class="dfu-upload-setting">
            Chunk timeout (ms)
            <input id="dfu-upload-timeout" type="number" min="1000" step="500" value="5000" />
          </label>
        </div>
        <div class="dfu-progress">
          <div class="dfu-progress-bar" id="dfu-progress-bar"></div>
        </div>
        <div id="dfu-progress-text" class="dfu-progress-text">Upload progress: 0%</div>
      </div>
    </section>

    <details class="section section-card dfu-card dfu-advanced-card" id="dfu-advanced-card">
      <summary class="section-card-title"><span class="icon settings" aria-hidden="true"></span>Advanced tools</summary>
      <div class="section-card-body">
        <div class="dfu-upload-actions">
          <button id="dfu-refresh-state" class="secondary">Refresh image state</button>
          <button id="dfu-test-image" class="secondary">Test uploaded image</button>
          <button id="dfu-confirm-image" class="secondary">Confirm active image</button>
          <button id="dfu-reset-session" class="secondary">Reset DFU session</button>
        </div>
        <div class="dfu-image-state" id="dfu-image-state">
          <div class="dfu-image-state-title">Image slots</div>
          <div class="dfu-image-state-list" id="dfu-image-state-list">
            <div class="dfu-image-state-empty">No image state loaded.</div>
          </div>
        </div>
      </div>
    </details>
  </div>


  <script>
    const CMD_SINGLE_SETTING = 0xA8;
    const CMD_SINGLE_VALUE = 0xA3;
    const CMD_STATUS = 0xA4;
    const CMD_SEND_ALL_SETTINGS = 0xA7;
    const CMD_SET_LOCATION_AND_TIME = 0xAF;
    const CMD_SEND_POSITION = 0xA5;
    const CMD_CHECK_PIN = 0xC2;
    const CMD_SEND_SINGLE_VAL = 0xA3;
    const CMD_SEND_TIMESTAMP = 0xCE;
    const VAL_UBLOX_TIME = 0xD8;
    const MSG_TIMESTAMP = 0x97;
    const MSG_CMD_CONFIRM = 0xF3;
    const MSG_LAST_POSITION = 0xFE;
    const LR_UPDATE_FW_MAJOR = 5;
    const LR_UPDATE_FW_MINOR = 0;

    const excludeFromImportExport = ['app_eui', 'device_pin', 'app_key', 'device_eui', 's_band_app_key', 's_band_network_key', 'tracker_type', 'ble_adv'];
    const mainCommands = {
      'cmd_join': 'Join LP1',
      'cmd_send_status_lr': 'Send status to LR1',
      'cmd_get_ublox_fix': 'Get UBLOX fix',
      'cmd_reset': 'Reboot device',
    };

    let device, server, txCharacteristic, rxCharacteristic;
    window.device = device;
    window.server = server;
    window.txCharacteristic = txCharacteristic;
    window.rxCharacteristic = rxCharacteristic;
    let readAllSettings = null;
    let autoLoaded = false;
    let lastPositionMessage = null;
    let mapInstance = null;
    let mapMarker = null;
    let mapReady = false;
    let leafletPromise = null;
    let userRequestedDisconnect = false;
    let lrUpdateMode = false;
    let flashLogState = {
      active: false,
      lines: [],
      buffer: '',
      startedAt: null,
      deviceName: ''
    };

    const logFooter = document.getElementById('logFooter');

    function toggleLog() {
      const basePadding = getComputedStyle(document.documentElement).getPropertyValue('--body-bottom-padding').trim() || '50px';
      logFooter.classList.toggle('open');
      document.body.style.paddingBottom = logFooter.classList.contains('open') ? logFooter.clientHeight + "px" : basePadding;
      const logElement = document.getElementById('log');
      logElement.scrollTop = logElement.scrollHeight;
    }
    window.toggleLog = toggleLog;

    function isLrUpdateFirmware(statusMessage) {
      return statusMessage
        && statusMessage.ver_fw_major === LR_UPDATE_FW_MAJOR
        && statusMessage.ver_fw_minor === LR_UPDATE_FW_MINOR;
    }

    function setLrUpdateMode(enabled) {
      lrUpdateMode = Boolean(enabled);
      document.body.classList.toggle('lr-update', lrUpdateMode);
    }

    function loadLeafletIfNeeded() {
      if (leafletPromise) {
        return leafletPromise;
      }
      leafletPromise = new Promise((resolve, reject) => {
        if (window.L && window.L.map) {
          resolve();
          return;
        }
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        link.integrity = 'sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=';
        link.crossOrigin = '';
        document.head.appendChild(link);

        const script = document.createElement('script');
        script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
        script.integrity = 'sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=';
        script.crossOrigin = '';
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load map library'));
        document.head.appendChild(script);
      });
      return leafletPromise;
    }

    function setMapStatus(message) {
      const statusEl = document.getElementById('map-status');
      if (statusEl) {
        statusEl.textContent = message;
      }
    }

    function updateMapOverlay() {
      const overlay = document.getElementById('map-overlay');
      if (!overlay) {
        return;
      }
      if (navigator.onLine) {
        overlay.classList.add('hidden');
      } else {
        overlay.classList.remove('hidden');
      }
    }

    async function ensureMapReady() {
      if (!navigator.onLine) {
        updateMapOverlay();
        return false;
      }
      updateMapOverlay();
      if (mapReady) {
        return true;
      }
      try {
        await loadLeafletIfNeeded();
        const mapContainer = document.getElementById('device-map');
        if (!mapContainer || mapInstance) {
          mapReady = true;
          return true;
        }
        mapInstance = L.map(mapContainer, {
          zoomControl: true,
          attributionControl: true
        }).setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap'
        }).addTo(mapInstance);
        mapReady = true;
        return true;
      } catch (error) {
        console.error(error);
        setMapStatus('Map failed to load.');
        return false;
      }
    }

    async function updateMapLocation() {
      if (!lastPositionMessage) {
        setMapStatus('Waiting for location...');
        return;
      }
      const { latitude, longitude } = lastPositionMessage;
      if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
        setMapStatus('Location unavailable.');
        return;
      }
      const ready = await ensureMapReady();
      if (!ready) {
        setMapStatus('Offline: map unavailable.');
        return;
      }
      setMapStatus(`Location: ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`);
      const coords = [latitude, longitude];
      if (!mapMarker) {
        mapMarker = L.marker(coords).addTo(mapInstance);
      } else {
        mapMarker.setLatLng(coords);
      }
      mapInstance.setView(coords, 14, { animate: false });
    }

    function handleConnectivityChange() {
      updateMapOverlay();
      if (navigator.onLine && lastPositionMessage) {
        updateMapLocation();
      }
    }

    window.addEventListener('online', handleConnectivityChange);
    window.addEventListener('offline', handleConnectivityChange);
    updateMapOverlay();
    const mapDetails = document.querySelector('#map-area details');
    if (mapDetails) {
      mapDetails.addEventListener('toggle', () => {
        if (mapDetails.open && mapInstance) {
          setTimeout(() => mapInstance.invalidateSize(), 0);
        }
      });
    }

    function formatFilenameTimestamp(date) {
      const pad = (num) => num.toString().padStart(2, '0');
      return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}_${pad(date.getHours())}${pad(date.getMinutes())}${pad(date.getSeconds())}`;
    }

    function sanitizeFilenamePart(value) {
      return (value || 'device').toString().replace(/[^A-Za-z0-9_-]+/g, '') || 'device';
    }

    function startFlashLogCapture() {
      flashLogState = {
        active: true,
        lines: [],
        buffer: '',
        startedAt: new Date(),
        deviceName: device && device.name ? device.name : ''
      };
      log('Starting flash log download...');
    }

    function finishFlashLogCapture(reason) {
      if (!flashLogState.active) {
        return;
      }

      if (flashLogState.buffer) {
        flashLogState.lines.push(flashLogState.buffer);
        flashLogState.buffer = '';
      }

      const lines = flashLogState.lines;
      const startedAt = flashLogState.startedAt || new Date();
      const deviceName = sanitizeFilenamePart(flashLogState.deviceName);
      const timestamp = formatFilenameTimestamp(startedAt);
      const filename = `raw_logs-${deviceName}_${timestamp}.txt`;

      const contents = lines.join('\n');
      const blob = new Blob([contents], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);

      log(`Flash log download complete (${lines.length} lines). File: ${filename}${reason ? ` (${reason})` : ''}`);
      flashLogState.active = false;
    }

    function bytesToBase64(bytes) {
      let binary = '';
      bytes.forEach((byte) => {
        binary += String.fromCharCode(byte);
      });
      return btoa(binary);
    }

    function handleFlashLogChunk(data) {
      let payloadLength = data.length >= 3 ? data[2] : 0;
      if (payloadLength === 0 || payloadLength > data.length - 3) {
        payloadLength = data.length - 3;
      }

      if (payloadLength <= 0 && data.length <= 3) {
        finishFlashLogCapture('empty payload');
        return;
      }

      const payload = data.slice(0);
      if (!payload.length) {
        return;
      }

      const base64Line = bytesToBase64(payload);
      if (flashLogState.active) {
        flashLogState.lines.push(base64Line);
      }
      log(`Flash log: ${base64Line}`);
    }

    async function loadSelectedSettings() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      if (!selectedFile) {
        return;
      }

      log(`Loading settings from ${selectedFile}...`);

      try {
        document.getElementById('settings-search').value = '';
        await loadSettings(selectedFile);
        log(`Settings from ${selectedFile} loaded successfully.`);
        displaySettings();
        displayMainCommands();
        displayCommands();
        document.body.classList.add('has-settings');
        await fetchAllSettings();
      } catch (error) {
        console.error(error);
        log(`Error loading settings: ${error.message}`, true);
      }
    };

    function exportToJson() {
      const settings = {};

      for (const [key, setting] of Object.entries(settingsData.settings)) {
        if (excludeFromImportExport.includes(key)) {
          continue;
        }

        const value = getInputValue(setting.id);

        if (['uint32', 'uint16', 'uint8', 'int32', 'int8', 'float'].includes(setting.conversion)) {
          settings[key] = Number(value);
        } else if (setting.conversion === 'bool') {
          settings[key] = value === 'true';
        } else {
          settings[key] = value;
        }
      }

      const json = JSON.stringify(settings, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      const deviceName = (getInputValue(settingsData.settings?.device_name?.id) || 'device')
        .toString()
        .trim()
        .replace(/[^A-Za-z0-9_-]+/g, '_')
        .replace(/^_+|_+$/g, '') || 'device';
      const now = new Date();
      const pad = (value) => String(value).padStart(2, '0');
      const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
      a.download = `${deviceName}_${timestamp}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function showImportPreviewModal({ title, subtitle, rows }) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('import-preview-overlay');
        const titleEl = document.getElementById('import-preview-title');
        const subtitleEl = document.getElementById('import-preview-subtitle');
        const rowsEl = document.getElementById('import-preview-rows');
        const changedOnlyToggle = document.getElementById('import-preview-changed-only');
        const cancelBtn = document.getElementById('import-preview-cancel');
        const confirmBtn = document.getElementById('import-preview-confirm');

        titleEl.textContent = title;
        subtitleEl.textContent = subtitle;
        function renderRows() {
          const changedOnly = changedOnlyToggle ? changedOnlyToggle.checked : false;
          rowsEl.innerHTML = rows.filter(row => !changedOnly || !row.unchanged).map((row) => `
          <tr class="${row.unchanged ? 'import-preview-unchanged' : ''}">
            <td>
              <div class="import-preview-setting">${row.name}</div>
              <div class="import-preview-meta">${row.key} (${row.id})</div>
              ${row.description ? `<div class="import-preview-desc">${row.description}</div>` : ''}
            </td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">${row.current}</td>
            <td class="${row.unchanged ? 'import-preview-cell-unchanged' : ''}">
              ${row.next}
              ${row.unchanged ? '<div class="import-preview-unchanged-tag">unchanged</div>' : ''}
            </td>
          </tr>
          `).join('');
        }
        renderRows();
        if (changedOnlyToggle) {
          changedOnlyToggle.onchange = renderRows;
        }

        function cleanup(result) {
          overlay.classList.add('hidden');
          cancelBtn.removeEventListener('click', onCancel);
          confirmBtn.removeEventListener('click', onConfirm);
          resolve(result);
        }

        function onCancel() {
          cleanup(false);
        }

        function onConfirm() {
          cleanup(true);
        }

        cancelBtn.addEventListener('click', onCancel);
        confirmBtn.addEventListener('click', onConfirm);
        overlay.classList.remove('hidden');
      });
    }

    async function importFromJson() {
      const fileInput = document.getElementById('import-file');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a file to import.');
        return;
      }

      console.log('Importing settings from file:', file.name);
      const reader = new FileReader();
      reader.onload = async function (event) {
        const progressContainer = document.getElementById('settings-progress');
        const progressBar = document.querySelector('#settings-progress div');
        const settingsSection = document.getElementById('settings-section');
        const commandsSection = document.getElementById('other-commands');
        const search = document.getElementById('search');
        document.getElementById('settings-search').value = '';
        filterSettings();

        try {
          const importedSettings = JSON.parse(event.target.result);
          const previewRows = [];

          let index = 0;
          const entries = Object.entries(importedSettings).filter(([key]) => !excludeFromImportExport.includes(key));

          for (const [key, value] of entries) {
            const settingObj = getByKey(key);
            if (!settingObj) {
              continue;
            }
            const currentValue = getInputValue(settingObj.id) ?? settingObj.default;
            const unchanged = isSettingValueEqual(key, settingObj, currentValue, value);
            previewRows.push({
              key,
              id: settingObj.id,
              name: settingObj.display_name || key,
              description: getSettingDescription(key),
              current: formatSettingValueForPreview(key, settingObj, currentValue, value, 'current'),
              next: formatSettingValueForPreview(key, settingObj, value, currentValue, 'next'),
              unchanged
            });
          }

          if (previewRows.length === 0) {
            showToast('No valid settings found in the import file.');
            return;
          }

          const ok = await showImportPreviewModal({
            title: `Import ${previewRows.length} settings`,
            subtitle: `File: ${file.name}`,
            rows: previewRows
          });
          if (!ok) {
            showToast('Import cancelled');
            return;
          }

          search.classList.add('hidden');
          progressBar.style.width = `0%`;
          progressContainer.style.display = 'block';
          settingsSection.classList.add('hidden');
          commandsSection.classList.add('hidden');

          for (const [key, value] of entries) {
            index++;

            const settingObj = getByKey(key);
            if (settingObj) {
              const start = Date.now();
              await updateBleSetting(settingObj.id, value);
              const elapsed = Date.now() - start;
              const remainingSleep = Math.max(0, 200 - elapsed);
              if (remainingSleep > 0) {
                await sleep(remainingSleep);
              }
            }
            progressBar.style.width = `${(index / entries.length) * 100}%`;
          }

          await fetchAllSettings();
        } catch (error) {
          console.error('Error importing settings:', error);
          showToast('Failed to import settings. Please check the file format.');
        } finally {
          search.classList.remove('hidden');
          settingsSection.classList.remove('hidden');
          commandsSection.classList.remove('hidden');
          progressContainer.style.display = 'none';
        }
        fileInput.value = '';
      };
      reader.readAsText(file);
    }

    function loadAvailableSettings() {
      try {
        populateSettingsIntoPage("Choose a settings file");
      } catch (error) {
        log(`Error fetching settings files: ${error.message}`, true);
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function decodeHwFwType(t) {
      switch (t) {
        case 0: return "default";
        case 1: return "rhinoedge";
        case 2: return "elephantedge";
        case 3: return "wisentedge";
        case 4: return "cattracker";
        case 5: return "rangeredge";
        case 6: return "rhinopuck";
        default: return "unknown";
      }
    }

    function decodeReset(reset) {
      switch (reset) {
        case 1: return "RESETPIN";
        case 2: return "DOG";
        case 4: return "SREQ";
        case 8: return "LOCKUP";
        default: return "unknown";
      }
    }


    function decodeStatusMessage(bytes) {
      function decode_uint8(byte, min, max) {
        var val;
        val = byte * (max - min) / 255 + min;
        return val;
      }
      // Skip header 0 and 1
      var reset = bytes[2];
      var err = bytes[3];
      var bat = (bytes[4] * 10) + 2500;
      var operation = bytes[5];
      var msg = 0;
      if (operation & 1) msg = 1;
      var locked = 0;
      if (operation & 2) locked = 1;
      var lr_join = 0;
      if (operation & 4) lr_join = 1;
      var lr_sat = operation >> 4;
      var temp = decode_uint8(bytes[6], -100, 100);
      var uptime = bytes[7];
      var acc_x = decode_uint8(bytes[8], -100, 100);
      var acc_y = decode_uint8(bytes[9], -100, 100);
      var acc_z = decode_uint8(bytes[10], -100, 100);
      var version = bytes[11];
      var ver_hw_minor = version & 0x0F;
      var ver_hw_major = version >> 4;
      version = bytes[12];
      var ver_fw_minor = version & 0x0F;
      var ver_fw_major = version >> 4;
      var ver_hw_type = bytes[13] & 0x0F;
      var ver_fw_type = bytes[13] >> 4;
      var chg = 0;
      if (bytes[14] > 0) chg = (bytes[14] * 100) + 5000;
      var features = bytes[15];
      var sat_support = 0;
      if (features & 1) sat_support = 1;
      var rf_scan = 0;
      if (features & 2) rf_scan = 1;
      var fence = 0;
      if (features & 4) fence = 1;
      var sat_try = features >> 4;
      //Errors
      var err_lr = 0;
      if (err & 1) err_lr = 1;
      var err_ble = 0;
      if (err & 2) err_ble = 1;
      var err_ublox = 0;
      if (err & 4) err_ublox = 1;
      var err_acc = 0;
      if (err & 8) err_acc = 1;
      var err_bat = 0;
      if (err & 16) err_bat = 1;
      var err_ublox_fix = 0;
      if (err & 32) err_ublox_fix = 1;
      var err_flash = 0;
      if (err & 64) err_flash = 1;
      return {
        reset: reset,
        bat: bat,
        chg: chg,
        temp: temp,
        uptime: uptime,
        locked: locked,
        msg: msg,
        acc_x: acc_x,
        acc_y: acc_y,
        acc_z: acc_z,
        lr_sat: lr_sat,
        err_lr: err_lr,
        err_lr_join: lr_join,
        err_ble: err_ble,
        err_ublox: err_ublox,
        err_acc: err_acc,
        err_bat: err_bat,
        err_ublox_fix: err_ublox_fix,
        err_flash: err_flash,
        ver_fw_major: ver_fw_major,
        ver_fw_minor: ver_fw_minor,
        ver_hw_major: ver_hw_major,
        ver_hw_minor: ver_hw_minor,
        ver_hw_type: ver_hw_type,
        ver_fw_type: ver_fw_type,
        sat_support: sat_support,
        sat_try: sat_try,
        rf_scan: rf_scan,
        fence: fence,
      };
    }

    async function displayStatusMessage(statusMessage) {
      const statusMessageElement = document.getElementById('status-message');
      const statusItems = [];
      let lrUpdateBanner = '';

      if (lrUpdateMode) {
        statusItems.push(
          `<div class="status-item" id="hw-version"><span class="icon hw-version"></span>${statusMessage.ver_hw_major}.${statusMessage.ver_hw_minor}</div>`,
          `<div class="status-item" id="fw-version"><span class="icon fw-version"></span>${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}</div>`,
          `<div class="status-item"><span class="icon uptime"></span>${statusMessage.uptime} day(s)</div>`,
          `<div class="status-item"><span class="icon temperature"></span>${statusMessage.temp.toFixed(1)}°C</div>`,
          `<div class="status-item"><span class="icon hw-type"></span>${decodeHwFwType(statusMessage.ver_hw_type)}</div>`
        );
        lrUpdateBanner = `
          <div class="lr-update-banner">
            <div>
              <div class="lr-update-title">Firmware to update the LR chip</div>
              <div class="lr-update-text">Next step: perform DFU to firmware v5 or higher.</div>
            </div>
            <div class="lr-update-actions">
              <button type="button" class="scan-button" onclick="openDfuPage()">Go to DFU</button>
            </div>
          </div>
        `;
      } else {
        const errors = Object.entries(statusMessage)
          .filter(([key, hasError]) => key.startsWith('err_') && hasError)
          .map(([key]) => key.slice(4).toUpperCase())
          .join(', ') || 'no errors';

        statusItems.push(
          `<div class="status-item" id="hw-version"><span class="icon hw-version"></span>${statusMessage.ver_hw_major}.${statusMessage.ver_hw_minor}</div>`,
          `<div class="status-item" id="fw-version"><span class="icon fw-version"></span>${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}</div>`,
          `<div class="status-item"><span class="icon uptime"></span>${statusMessage.uptime} day(s)</div>`,
          `<div class="status-item"><span class="icon temperature"></span>${statusMessage.temp.toFixed(1)}°C</div>`,
          `<div class="status-item"><span class="icon hw-type"></span>${decodeHwFwType(statusMessage.ver_hw_type)}</div>`,
          `<div class="status-item"><span class="icon messages"></span>${statusMessage.msg}</div>`,
          `<div class="status-item"><span class="icon battery"></span>${statusMessage.bat}mV</div>`,
          `<div class="status-item"><span class="icon charging"></span>${statusMessage.chg ? 'charging' : 'discharging'}</div>`,
          `<div class="status-item"><span class="icon accelerometer"></span>${statusMessage.acc_x.toFixed(1)}, ${statusMessage.acc_y.toFixed(1)}, ${statusMessage.acc_z.toFixed(1)}</div>`,
          `<div class="status-item"><span class="icon locked"></span>${statusMessage.locked ? 'PIN set' : 'PIN not set'}</div>`,
          `<div class="status-item"><span class="icon reset"></span>${decodeReset(statusMessage.reset)}</div>`,
          `<div class="status-item"><span class="icon ublox-time"></span><span id="ublox-timestamp">fetching time...</span></div>`,
          `<div class="status-item"><span class="icon ublox-location"></span><span id="ublox-location">fetching location...</span></div>`,
          `<div class="status-item"><span class="icon errors"></span>${errors}</div>`
        );
      }

      statusMessageElement.innerHTML = `
        <div class="status-header">
          <h4>${device.name}</h4>
          <a href="#" onclick="requestStatusMessage()">
            <div class="status-item"><span class="icon refresh"></span>refresh</div>
          </a>
        </div>
        ${lrUpdateBanner}
        <div class="status-items">
          ${statusItems.join('')}
        </div>
      `;

      try {
        const dfuInfo = {
          deviceName: device && device.name ? device.name : '',
          fwVersion: `${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}`,
          hwVersion: `${statusMessage.ver_hw_major}.${statusMessage.ver_hw_minor}`,
          fwType: statusMessage.ver_fw_type,
          hwType: statusMessage.ver_hw_type,
          updatedAt: Date.now(),
        };
        sessionStorage.setItem('dfuDeviceInfo', JSON.stringify(dfuInfo));
      } catch (error) {
        console.warn('Failed to store DFU device info', error);
      }

      if (!lrUpdateMode) {
        await executeBleCommand([0x20, CMD_SEND_POSITION, 0x00]);

        if (compareSemanticVersion(statusMessage.ver_fw_major, statusMessage.ver_fw_minor, 6, 11) >= 0) {
          await executeBleCommand([0x20, CMD_SEND_TIMESTAMP, 0x00]);
        } else {
          await executeBleCommand([0x20, CMD_SEND_SINGLE_VAL, 0x01, VAL_UBLOX_TIME]);
        }
      }
    }

    function compareSemanticVersion(major1, minor1, major2, minor2) {
      if (major1 > major2) {
        return 1;
      } else if (major1 < major2) {
        return -1;
      } else {
        if (minor1 > minor2) {
          return 1;
        } else if (minor1 < minor2) {
          return -1;
        } else {
          return 0;
        }
      }
    }

    function displaySettings() {
      const settingsSection = document.getElementById('settings-section');
      settingsSection.innerHTML = '';
      for (const [groupName, group] of Object.entries(groupAndSortSettings(settingsData.settings))) {
        const groupWrapper = document.createElement('div');
        groupWrapper.className = 'settings-group is-collapsed';

        const groupToggle = document.createElement('button');
        groupToggle.type = 'button';
        groupToggle.className = 'group-toggle';
        groupToggle.setAttribute('aria-expanded', 'false');
        groupToggle.innerHTML = `
          <span class="group-title">${groupName.replace(/_/g, " ")}</span>
          <span class="group-caret" aria-hidden="true"></span>
        `;
        groupToggle.addEventListener('click', () => toggleGroup(groupWrapper));

        const settingsContainer = document.createElement('div');
        settingsContainer.className = 'settings-container';

        for (const [key, setting] of Object.entries(group)) {
          const row = document.createElement('div');
          row.className = 'setting disabled with-controls';
          row.setAttribute('id', `setting-${setting.id}`);
          const settingDescription = getSettingDescription(key);
          row.setAttribute('data-search', `${key} ${setting.display_name} ${settingDescription}`.trim());
          row.innerHTML = `
          <h4>${setting.display_name} <small>${key} (${setting.id})</small></h4> 
          ${settingDescription ? `<p class="setting-help">${settingDescription}</p>` : ""}
          
          ${renderInput(key, setting)}

          <div class="setting-controls">
            <button id="update-button-${setting.id}" onclick="updateSetting('${setting.id}')">Update</button>
            <button id="reset-button-${setting.id}" onclick="setDefaultValue('${setting.id}')" class="secondary" title="Default value: ${setting.default}">Set default</button>
          </div>
        `;
          settingsContainer.appendChild(row);
        }
        groupWrapper.appendChild(groupToggle);
        groupWrapper.appendChild(settingsContainer);
        settingsSection.appendChild(groupWrapper);
      }
    }

    function displayCommands() {
      const commandsSection = document.getElementById('commands-buttons-section');
      commandsSection.innerHTML = '';
      for (const [key, command] of Object.entries(settingsData.commands)) {
        if ((command.length !== 0 && command.length !== 1) || dangerousCommands.some(rx => rx.test(key)) || key in mainCommands) {
          continue;
        }

        const row = document.createElement('div');
        row.className = 'command';
        row.setAttribute('id', `command-${command.id}`);
        const label = getCommandLabel(key);
        const description = getCommandDescription(key);
        const commandInputMeta = getCommandInputMeta(key);
        let helperHtml = '';
        if (key === 'cmd_send_single_val') {
          const valueOptions = getCommandValueOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Value</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${valueOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        } else if (key === 'cmd_send_single_setting') {
          const settingOptions = getCommandSettingOptions();
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Setting</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${settingOptions.map(option => `<option value="${option.id}">${option.name} (${option.id})</option>`).join('')}
            </select>
          `;
        } else if (commandInputMeta && commandInputMeta.options) {
          helperHtml = `
            <label class="command-helper-label" for="command-select-${command.id}">Value</label>
            <select id="command-select-${command.id}" class="command-helper-input">
              ${commandInputMeta.options.map(option => `<option value="${option.value}">${option.label}</option>`).join('')}
            </select>
          `;
        } else if (commandInputMeta && commandInputMeta.input) {
          const placeholder = commandInputMeta.input.placeholder || '';
          const labelText = commandInputMeta.input.label || 'Value';
          const dataFormat = commandInputMeta.input.format || 'uint8';
          helperHtml = `
            <label class="command-helper-label" for="command-input-${command.id}">${labelText}</label>
            <input id="command-input-${command.id}" class="command-helper-input" type="text" placeholder="${placeholder}" data-format="${dataFormat}" />
          `;
        }
        row.innerHTML = `
          <button id="command-button-${command.id}" onclick="executeCommand('${command.id}')"${
            description ? ` title="${description}"` : ""
          }>${label}</button>
          ${helperHtml}
          <div class="command-meta">${key} (${command.id})</div>
        `;
        commandsSection.appendChild(row);
      }
    }

    function copyDeviceInfo() {
      if (!settingsData || !settingsData.settings) {
        return;
      }

      function safeGetValue(name) {
        if(name in settingsData.settings) {
          return getInputValue(settingsData.settings[name].id);
        }
      }

      const values = [
        safeGetValue("device_name"),
        safeGetValue("device_eui"),
        safeGetValue("app_key"),
        safeGetValue("app_eui"),
        safeGetValue("device_pin").split("").filter((_, index) => (index + 1) % 2 === 0).join(""),
        document.getElementById('hw-version').textContent,
        document.getElementById('fw-version').textContent,
        safeGetValue("s_band_dev_adr"),
        safeGetValue("s_band_app_key"),
        safeGetValue("s_band_network_key"),
      ].filter(value => value).join("\t");

      navigator.clipboard.writeText(values).then(() => {
        showToast('Device info copied to clipboard');
      }).catch(err => {
        showToast('Failed to copy to clipboard');
      });
    }

    async function loadDfuScriptsIfNeeded() {
      if (window.DfuApp && window.DfuApp.init) {
        return;
      }

      const loadScript = (src) => new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.body.appendChild(script);
      });

      await loadScript('dfu/cbor.js');
      await loadScript('dfu/mcumgr.js');
      await loadScript('dfu/dfu.js');
    }

    function toggleDfuView(showDfu) {
      const sectionsToHide = [
        document.getElementById('settings-area'),
        document.getElementById('other-commands'),
        document.getElementById('map-area'),
      ];
      const container = document.getElementById('container');
      const dfuContainer = document.getElementById('dfu-container');
      const dfuSection = document.getElementById('dfu-section');
      if (showDfu) {
        sectionsToHide.forEach(section => section && section.classList.add('hidden'));
        container && container.classList.add('hidden');
        dfuContainer && dfuContainer.classList.remove('hidden');
        dfuSection && dfuSection.classList.remove('hidden');
        document.body.classList.add('dfu-active');
      } else {
        sectionsToHide.forEach(section => section && section.classList.remove('hidden'));
        container && container.classList.remove('hidden');
        dfuContainer && dfuContainer.classList.add('hidden');
        dfuSection && dfuSection.classList.add('hidden');
        document.body.classList.remove('dfu-active');
      }
    }
    window.toggleDfuView = toggleDfuView;

    function setDfuWarningOverlay(visible) {
      const overlay = document.getElementById('dfu-warning-overlay');
      if (!overlay) return;
      overlay.classList.toggle('hidden', !visible);
    }

    async function proceedOpenDfuPage() {
      if (!document.body.classList.contains('connected')) {
        showToast('Connect to a device before starting DFU.');
        return;
      }
      try {
        await loadDfuScriptsIfNeeded();
        if (window.DfuApp && window.DfuApp.init) {
          window.DfuApp.init({ device, useExistingConnection: true });
        }
        toggleDfuView(true);
      } catch (error) {
        showToast('Failed to load DFU tools.');
        console.error(error);
      }
    }

    async function openDfuPage() {
      setDfuWarningOverlay(true);
    }

    document.getElementById('dfu-back-top').addEventListener('click', () => {
      toggleDfuView(false);
    });

    const dfuWarningCancel = document.getElementById('dfu-warning-cancel');
    const dfuWarningProceed = document.getElementById('dfu-warning-proceed');
    if (dfuWarningCancel) {
      dfuWarningCancel.addEventListener('click', () => setDfuWarningOverlay(false));
    }
    if (dfuWarningProceed) {
      dfuWarningProceed.addEventListener('click', async () => {
        setDfuWarningOverlay(false);
        await proceedOpenDfuPage();
      });
    }

    function sendLocationAndTimeCommand(latitude, longitude) {
      const bytesArray = new Uint8Array(12);
      bytesArray.set(new Uint8Array(new Int32Array([longitude * Math.pow(10, 7)]).buffer), 0);
      bytesArray.set(new Uint8Array(new Int32Array([latitude * Math.pow(10, 7)]).buffer), 4);
      bytesArray.set(new Uint8Array(new Int32Array([new Date() / 1000]).buffer), 8);

      executeBleCommand([0x20, CMD_SET_LOCATION_AND_TIME, 12, ...bytesArray]);
    }

    function setLocationAndTime() {
      if (!navigator.geolocation) {
        alert("Geolocation is not supported by this browser.");
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          log(`Got location: ${position.coords.latitude}, ${position.coords.longitude}`);
          sendLocationAndTimeCommand(position.coords.latitude, position.coords.longitude);
        },
        (error) => {
          let errorMessage = '';
          if (error.code === error.PERMISSION_DENIED) {
            errorMessage = "User denied the request for location";
          } else if (error.code === error.POSITION_UNAVAILABLE) {
            errorMessage = "Location information is unavailable";
          } else if (error.code === error.TIMEOUT) {
            errorMessage = "The request to get user location timed out";
          } else {
            errorMessage = "An unknown error occurred";
          }

          if (lastPositionMessage) {
            showToast(`${errorMessage}. Using last known location.`);
            sendLocationAndTimeCommand(lastPositionMessage.latitude, lastPositionMessage.longitude);
          } else {
            showToast(errorMessage);
          }
        }
      );
    }

    function displayMainCommands() {
      const mainCommandsElement = document.getElementById('main-commands');
      const activeCommands = lrUpdateMode
        ? { 'cmd_reset': 'Reboot device' }
        : mainCommands;

      mainCommandsElement.innerHTML = Object.entries(activeCommands).map(([key, label]) => {
        const command = settingsData.commands[key];
        if (!command) {
          return '';
        }
        return `<button id="command-button-${command.id}" onclick="executeCommand('${command.id}')">${label}</button>`;
      }).join('');

      if (!lrUpdateMode) {
        mainCommandsElement.innerHTML += `
          <button class="hidden-when-no-status" onclick="setLocationAndTime()">Set location & time</button>
          <button class="hidden-when-no-status" onclick="copyDeviceInfo()">Copy device info</button>
        `;
      }
    }

    function log(message, isError = false) {
      const logElement = document.getElementById('log');
      const logEntry = document.createElement('div');
      logEntry.classList.add('log-entry');
      if (isError) {
        logEntry.classList.add('error');
      }
      logEntry.textContent = `[${new Date().toLocaleTimeString("nl-NL")}] ${message}`;
      logElement.appendChild(logEntry);
      logElement.scrollTop = logElement.scrollHeight;
    }

    function autoSelectAndLoadSettings(statusMessage) {
      const settingsDropdown = document.getElementById('settings-dropdown');
      const fwVersion = `v${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}`;

      for (let i = 0; i < settingsDropdown.options.length; i++) {
        if (settingsDropdown.options[i].text.includes(fwVersion)) {
          settingsDropdown.selectedIndex = i;
          loadSelectedSettings();
          break;
        }
      }
    }

    function onDisconnected() {
      log('Disconnected from device');
      if (flashLogState.active) {
        finishFlashLogCapture('disconnected');
      }
      autoLoaded = false;
      setLrUpdateMode(false);
      document.body.classList.remove('connected');
      document.body.classList.remove('has-status');
      document.body.classList.remove('has-settings');
      if (document.body.classList.contains('dfu-active')) {
        const awaiting = window.DfuApp && window.DfuApp.isAwaitingReboot && window.DfuApp.isAwaitingReboot();
        if (awaiting) {
          showToast('Device rebooted. Waiting to reconnect for DFU.');
        } else {
          showToast('Device disconnected. Use Reconnect to continue DFU.');
        }
      }
      if (userRequestedDisconnect) {
        try {
          sessionStorage.removeItem('dfuDeviceInfo');
        } catch (error) {
          console.warn('Failed to clear DFU device info', error);
        }
        userRequestedDisconnect = false;
      }
      lastPositionMessage = null;
      setMapStatus('Waiting for location...');
      if (mapMarker && mapInstance) {
        mapInstance.removeLayer(mapMarker);
      }
      mapMarker = null;
    }

    const connectButton = document.getElementById('connect-button');
    const deviceNameFilterInput = document.getElementById('device-name-filter');

    function parseDeviceNameFilters(value) {
      const rawEntries = String(value || '')
        .split(',')
        .map(entry => entry.trim())
        .filter(entry => entry.length > 0);

      return rawEntries.map(entry => {
        // Be forgiving: treat bare values as prefixes. Use a trailing '*'
        // explicitly as well (e.g., "SP05*").
        const normalized = entry.endsWith('*') ? entry.slice(0, -1).trim() : entry;
        if (!normalized) return null;
        return { namePrefix: normalized };
      }).filter(Boolean);
    }

    async function connectToDevice(selectedDevice, options = {}) {
      const connectLabel = connectButton.textContent;
      try {
        connectButton.disabled = true;
        connectButton.textContent = 'Connecting...';
        userRequestedDisconnect = false;

        device = selectedDevice;
        window.device = device;
        log(`Connecting to ${device && device.name ? device.name : 'device'}...`);
        device.addEventListener('gattserverdisconnected', onDisconnected);
        if (options.reuseConnected && device.gatt && device.gatt.connected) {
          log('Reusing existing GATT connection.');
          server = device.gatt;
        } else {
          log('Opening new GATT connection...');
          server = await device.gatt.connect();
        }
        window.server = server;

        log('Discovering UART service...');
        const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
        txCharacteristic = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e');
        rxCharacteristic = await service.getCharacteristic('6e400002-b5a3-f393-e0a9-e50e24dcca9e');
        window.txCharacteristic = txCharacteristic;
        window.rxCharacteristic = rxCharacteristic;

        log('Enabling notifications...');
        await txCharacteristic.startNotifications();
        txCharacteristic.addEventListener('characteristicvaluechanged', handleNotifications);

        document.body.classList.add('connected');
        log(`Connected to device: ${device.name}`);

        loadAvailableSettings();
        await checkPin(document.getElementById('pincode').value);
      } catch (error) {
        log(`Error: ${error.message}`, true);
      } finally {
        connectButton.textContent = connectLabel;
        connectButton.disabled = false;
      }
    }
    window.connectToDevice = connectToDevice;

    connectButton.addEventListener('click', async function () {
      const manufacturerFilter = {
        manufacturerData: [{ companyIdentifier: 0x0A61 }]
      };
      const nameFilters = parseDeviceNameFilters(deviceNameFilterInput.value);
      const filters = nameFilters.length
        ? nameFilters.map(nameFilter => ({ ...manufacturerFilter, ...nameFilter }))
        : [manufacturerFilter];

      if (nameFilters.length) {
        const filterSummary = nameFilters
          .map(filter => filter.name ? filter.name : `${filter.namePrefix}*`)
          .join(', ');
        log(`Applying device name filters: ${filterSummary}`);
      }

      try {
        const selectedDevice = await navigator.bluetooth.requestDevice({
          filters,
          optionalServices: [
            '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
            '8d53dc1d-1db7-4cd3-868b-8a527460aa84'
          ]
        });
        await connectToDevice(selectedDevice);
      } catch (error) {
        log(`Error: ${error.message}`, true);
      }
    });

    document.getElementById('disconnect-button').addEventListener('click', function () {
      if (device && device.gatt.connected) {
        userRequestedDisconnect = true;
        device.gatt.disconnect();
      }
    });

    async function autoReconnectIfAvailable() {
      if (!navigator.bluetooth || !navigator.bluetooth.getDevices) {
        return;
      }
      let storedInfo = null;
      try {
        const raw = sessionStorage.getItem('dfuDeviceInfo');
        if (raw) {
          storedInfo = JSON.parse(raw);
        }
      } catch (error) {
        storedInfo = null;
      }
      if (!storedInfo || !storedInfo.deviceName) {
        return;
      }
      try {
        const devices = await navigator.bluetooth.getDevices();
        const matching = devices.find(knownDevice => knownDevice.name === storedInfo.deviceName);
        if (matching) {
          log(`Reconnecting to ${matching.name}...`);
          await connectToDevice(matching);
        }
      } catch (error) {
        console.warn('Auto reconnect failed', error);
      }
    }

    autoReconnectIfAvailable();

    async function handleNotifications(event) {
      const value = event.target.value;
      const data = new Uint8Array(value.buffer);

      log(`Raw data received: ${bytesToHex(data)}`);

      const port = data[0];
      try {
        const flashLogPort = settingsData && settingsData.ports ? settingsData.ports.port_flash_log : null;
        if (flashLogPort && port === flashLogPort) {
          handleFlashLogChunk(data);
          return;
        }
        if (port === 31 && data.length >= 5 && data[1] === MSG_CMD_CONFIRM && data[3] === CMD_CHECK_PIN && data[4] === 0x01) {
          log(`PIN OK`);
          await requestStatusMessage();
        } else if (port === 31 && data.length >= 5 && data[1] === MSG_CMD_CONFIRM && data[3] === 0xBB && data[4] === 0x01) {
          finishFlashLogCapture('device confirm');
        } else if (port === 3) {
          decodeBleValueResponse(data.slice(1));
        } else if (port === 30 && data[1] == VAL_UBLOX_TIME) {
          const timestamp = bytesToSetting(settingsData.values['ublox_time'], data.slice(3));
          log(`Decoded: ublox time = ${timestamp}`);
          const timestampEl = document.getElementById('ublox-timestamp');
          if (timestampEl) {
            timestampEl.textContent = new Date(timestamp * 1000).toLocaleString("nl-NL");
          }
        } else if (port === 18 && data[1] === MSG_TIMESTAMP) {
          const timestamp = new DataView(new Uint8Array(data.slice(3)).buffer).getInt32(0, true)
          const timestampEl = document.getElementById('ublox-timestamp');
          if (timestampEl) {
            timestampEl.textContent = new Date(timestamp * 1000).toLocaleString("nl-NL");
          }
          log(`Decoded: timestamp = ${JSON.stringify(timestamp)}`);
        } else if (port === 31 && data[1] === MSG_LAST_POSITION) {
          lastPositionMessage = decodeLastPositionMessage(data.slice(3));
          const locationEl = document.getElementById('ublox-location');
          if (locationEl) {
            locationEl.innerHTML = `<a href="https://maps.google.com/?q=${lastPositionMessage.latitude},${lastPositionMessage.longitude}" target="_blank">${lastPositionMessage.latitude.toFixed(3)},${lastPositionMessage.longitude.toFixed(3)}</a>`;
          }
          log(`Decoded: last postion = ${JSON.stringify(lastPositionMessage)}`);
          updateMapLocation();
        } else if (port === 4) {
          const statusMessage = decodeStatusMessage(data.slice(1));
          setLrUpdateMode(isLrUpdateFirmware(statusMessage));
          await displayStatusMessage(statusMessage);
          document.body.classList.add('has-status');
          if (!autoLoaded) {
            autoLoaded = true;
            autoSelectAndLoadSettings(statusMessage);
          }
        } else {
          await decodeMessage(data);
        }
      } catch (error) {
        console.error(error);
        log(`Error decoding response: ${error.message}`, true);
      }
    }

    function decodeLastPositionMessage(bytes) {
      let val = (bytes[3] << 24) | (bytes[2] << 16) | (bytes[1] << 8) | bytes[0];
      const longitude = val / 10000000; // gps latitude, units: °
      val = (bytes[7] << 24) | (bytes[6] << 16) | (bytes[5] << 8) | bytes[4];
      const latitude = val / 10000000; // gps longitude, units: °
      val = (bytes[11] << 24) | (bytes[10] << 16) | (bytes[9] << 8) | bytes[8];
      const altitude = val / 1000; // gps altitude, units: m
      val = (bytes[15] << 24) | (bytes[14] << 16) | (bytes[13] << 8) | bytes[12];
      const timestamp = val;
      return { latitude, longitude, altitude, timestamp };
    }

    async function decodeMessage(data) {
      const port = data[0];
      if (!settingsData) {
        log(`No settings data available to decode message for port: ${port}`);
        return;
      }

      const portName = Object.keys(settingsData.ports).find(key => settingsData.ports[key] === port);
      if (portName) {
        const id = data[1];
        const message = Object.entries(settingsData.messages).find(([key, msg]) => msg.port === portName && msg.id.toUpperCase() === `0x${id.toString(16)}`.toUpperCase());
        if (message) {
          const [key, msg] = message;
          const valueBytes = data.slice(3, 3 + msg.length);

          if (key === 'msg_cmd_confirm' && valueBytes[0] === CMD_SET_LOCATION_AND_TIME) {
            // Updated time and position, refresh time and position
            await requestStatusMessage();
          } else {
            log(`Decoded message: ${key} = ${bytesToSetting(msg, valueBytes)}`);
          }
        } else {
          throw new Error(`No message found for port: ${portName} and id: 0x${id.toString(16)}`);
        }
      } else {
        throw new Error('No decoder available for port: ' + port);
      }
    }

    function decodeBleValueResponse(bytes) {
      for (let i = 0; i < bytes.length;) {
        const id = bytes[i++];
        const len = bytes[i++];
        const valueBytes = bytes.slice(i, i + len);

        const [key, setting] = getById(id);
        let value = bytesToSetting(setting, valueBytes);
        log(`Decoded setting response: ${key} = ${value}`);
        updateSettingDisplay(setting.id, value);
        i += len;
      }
    }

    function arraysEqual(arr1, arr2) {
      // Check if lengths are different
      if (arr1.length !== arr2.length) {
        return false;
      }

      // Check if all elements are equal
      return arr1.every((element, index) => element === arr2[index]);
    }

    function isValueNotDefault(settingId, value) {
      const [key, valueMeta] = getById(settingId);
      if (valueMeta.conversion === 'byte_array') {
        return !arraysEqual(stringToUint8Array(value, valueMeta.length), stringToUint8Array(stripBytes(valueMeta.default), valueMeta.length));
      }
      return value !== valueMeta.default;
    }

    function updateSettingDisplay(settingId, value) {
      setInputValue(settingId, value);

      const rowElement = document.getElementById(`setting-${settingId}`);
      if (rowElement) {
        rowElement.classList.remove('disabled');
        if (isValueNotDefault(settingId, value)) {
          rowElement.classList.add('value-not-default');
        } else {
          rowElement.classList.remove('value-not-default');
        }
      }
    }

    async function requestBleValue(id, cmd) {
      if (typeof id === 'string' || id instanceof String) {
        id = parseInt(id, 16);
      }

      return executeBleCommand([0x20, cmd, 0x01, id]);
    }

    async function executeCommand(cmd) {
      if (typeof cmd === 'string' || cmd instanceof String) {
        cmd = parseInt(cmd, 16);
      }

      const [key, commandMeta] = getById(cmd);
      showToast(`Executing command: ${key}`);
      if (key === 'cmd_flash_get_all') {
        startFlashLogCapture();
      }
        if (commandMeta && commandMeta.length === 1) {
          const selectEl = document.getElementById(`command-select-${commandMeta.id}`);
          const inputEl = document.getElementById(`command-input-${commandMeta.id}`);
          let value = 0;
          if (selectEl) {
          const selected = selectEl.value;
          if (selected && selected.startsWith('0x')) {
            value = parseInt(selected, 16);
          } else {
            value = parseInt(selected, 10);
          }
          } else if (inputEl) {
          const rawValue = inputEl.value.trim();
          const format = inputEl.getAttribute('data-format') || 'uint8';
          if (rawValue.length === 0) {
            value = 0;
          } else if (format === 'hex8') {
            const cleaned = rawValue.replace(/^0x/i, '');
            const parsed = parseInt(cleaned, 16);
            if (Number.isNaN(parsed)) {
              showToast('Invalid hex value');
              return;
            }
            value = parsed;
          } else {
            const parsed = parseInt(rawValue, 10);
            if (Number.isNaN(parsed)) {
              showToast('Invalid numeric value');
              return;
            }
            value = parsed;
          }
        } else if (commandMeta && commandMeta.value !== undefined) {
          value = commandMeta.value;
        }
        return executeBleCommand([0x20, cmd, 0x01, value]);
      }
      return executeBleCommand([0x20, cmd, 0x00]);
    }

    async function requestStatusMessage() {
      return executeBleCommand([0x20, CMD_STATUS, 0x00])
    }

    async function checkPin(pin_in) {
      // add zeros to each number in PIN ("1234" -> "01020304")
      let pin_out = "0" + pin_in.split("").join("0");
      // add zeros to the end (to have 16 byte data length)
      pin_out = pin_out + "000000000000000000000000";
      return executeBleCommand([0x20, CMD_CHECK_PIN, 16, ...stringToUint8Array(pin_out, 16)]);
    }

    async function requestAllSettings() {
      return executeBleCommand([0x20, CMD_SEND_ALL_SETTINGS, 0x00])
    }

    async function writeGattValue(characteristic, buffer) {
      if (characteristic.writeValueWithResponse) {
        return characteristic.writeValueWithResponse(buffer);
      }
      if (characteristic.writeValueWithoutResponse) {
        return characteristic.writeValueWithoutResponse(buffer);
      }
      return characteristic.writeValue(buffer);
    }

    async function executeBleCommand(command) {
      log(`Sending command ${bytesToHex(command)}`);

      const commandBuffer = new Uint8Array(command).buffer;
      try {
        await writeGattValue(rxCharacteristic, commandBuffer);
      } catch (error) {
        log(`Error sending command: ${error.message}`, true);
      }
    }

    async function fetchAllSettings() {
      await requestAllSettings();
    }

    async function updateBleSetting(settingId, newValue) {
      const [settingKey, setting] = getById(settingId);

      let valueBytes = settingToBytes(settingKey, setting, newValue);

      const length = valueBytes.length;
      const command = [0x03, parseInt(settingId, 16), length, ...valueBytes];
      const commandBuffer = new Uint8Array(command).buffer;

      log(`Sending update for ${settingKey} (ID: ${settingId}) with value: ${newValue}`);

      try {
        await writeGattValue(rxCharacteristic, commandBuffer);
        log(`Value updated successfully for ${settingKey} (ID: ${settingId})`);
      } catch (error) {
        log(`Error sending update for ${settingKey}: ${error.message}`, true);
        throw error;
      }
    }

    async function updateSetting(settingId) {
      const rowElement = document.getElementById(`setting-${settingId}`);
      try {
        rowElement.classList.add('disabled');
        await updateBleSetting(settingId, getInputValue(settingId));
        await sleep(1000);
        await requestBleValue(settingId, CMD_SINGLE_SETTING);
      } finally {
        rowElement.classList.remove('disabled');
      }
    }
  </script>
</body>

</html>
