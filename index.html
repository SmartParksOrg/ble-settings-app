<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenCollar Edge BLE Web Connect</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #90AE9B; /* Light green background */
    }
    .log {
      background-color: #f9f9f9;
      border: 1px solid #ccc;
      padding: 10px;
      height: 200px;
      overflow-y: scroll;
      white-space: pre-wrap;
      display: none; /* Hidden by default */
    }
    .log-entry {
      margin-bottom: 5px;
    }
    .controls {
      margin-bottom: 20px;
    }
    .settings-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
      table-layout: fixed;
    }
    .settings-table th, .settings-table td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
      vertical-align: top;
      word-wrap: break-word;
    }
    .settings-table th {
      background-color: #f2f2f2;
    }

    .name-column {
      width: 18%;
      word-wrap: break-word;
      white-space: normal;
    }
    .id-column {
      width: 5%;
      white-space: nowrap;
    }
    .value-column {
      background-color: #e0f7fa;
      width: 14%;
    }
    .default-column, 
    .min-column, 
    .max-column {
      width: 12%;
      font-size: 90%;
    }
    .new-value-column {
      width: 20%;
    }
    .action-column {
      width: 14%;
    }

    .value-updated {
      background-color: #ccffcc !important;
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-left-color: #000;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
    }
    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    input.invalid {
      border: 2px solid red;
    }

    button {
      background-color: #52735E; /* Dark green buttons */
      color: white;
      padding: 10px 20px;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background-color: #426052; /* Slightly darker on hover */
    }

    .toggle-button {
      margin-bottom: 10px;
      background-color: #52735E;
      color: white;
      padding: 5px 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <img src="smartparks-logo.png" alt="Smart Parks Logo" style="width: 200px; display: block; margin-bottom: 20px;"> <!-- Add logo -->

  <h1>OpenCollar Edge BLE Web Connect</h1>

  <div class="controls">
    <button id="connect-button">Connect to Device</button>
    <button id="disconnect-button" disabled>Disconnect</button>
    <div id="settings-selection" style="display:none;">
      <label for="settings-dropdown">Choose a settings file:</label>
      <select id="settings-dropdown"></select>
      <button id="load-settings-button">Load setting.json</button> <!-- Load button -->
    </div>
    <div id="spinner-container" style="display: none;">
      <div class="spinner"></div> <!-- Spinner -->
    </div>
    <h2>Status: <span id="status">Disconnected</span></h2>
    <h2>Device Name: <span id="device-name"></span></h2>
  </div>

  <h2>Log</h2>
  <button class="toggle-button" id="toggle-log">Show Log</button> <!-- Toggle button -->

  <div class="log" id="log"></div>

  <h2>Settings</h2>
  <table class="settings-table" id="settings-table">
    <thead>
      <tr>
        <th class="name-column">Setting Name</th>
        <th class="id-column">ID</th>
        <th class="value-column">Value</th>
        <th class="default-column">Default</th>
        <th class="min-column">Min</th>
        <th class="max-column">Max</th>
        <th class="new-value-column">New Value</th>
        <th class="action-column">Action</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    let device, server, txCharacteristic, rxCharacteristic;
    let settingsData = null;
    let currentSettingIndex = 0;
    const spinnerHtml = '<div class="spinner"></div>';
    let settingsKeys = [];

    // Toggle log visibility
    document.getElementById('toggle-log').addEventListener('click', function () {
      const logElement = document.getElementById('log');
      if (logElement.style.display === 'none') {
        logElement.style.display = 'block';
        this.textContent = 'Hide Log';
      } else {
        logElement.style.display = 'none';
        this.textContent = 'Show Log';
      }
    });

    document.getElementById('load-settings-button').addEventListener('click', function() {
      const selectedFile = document.getElementById('settings-dropdown').value;
      log(`Loading settings from ${selectedFile}...`);
      loadSettings(selectedFile); // Load the selected JSON file
    });

    async function loadAvailableSettings() {
      try {
        // Static list of settings files
        const files = [
          "settings-v6.8.1.json",
          "settings-v4.4.2.json"
        ];
        const dropdown = document.getElementById('settings-dropdown');
        dropdown.innerHTML = ''; // Clear previous options

        files.forEach(file => {
          const option = document.createElement('option');
          option.value = `./settings/${file}`;
          option.textContent = file;
          dropdown.appendChild(option);
        });

        document.getElementById('settings-selection').style.display = 'block'; // Show the dropdown and load button
      } catch (error) {
        log(`Error fetching settings files: ${error.message}`, true);
      }
    }

    async function loadSettings(selectedFile) {
      try {
        const response = await fetch(selectedFile); // Load the selected JSON file
        settingsData = await response.json();
        log(`Settings from ${selectedFile} loaded successfully.`);
        settingsKeys = Object.keys(settingsData.settings);
        displaySettings();
        currentSettingIndex = 0;
        fetchNextSetting(); // Start fetching settings after loading the JSON
      } catch (error) {
        log(`Error loading settings: ${error.message}`, true);
      }
    }

    function displaySettings() {
      const settingsTableBody = document.querySelector('#settings-table tbody');
      settingsTableBody.innerHTML = '';

      for (const key of settingsKeys) {
        const setting = settingsData.settings[key];
        const row = document.createElement('tr');
        row.setAttribute('id', `setting-${setting.id}`);
        row.innerHTML = `
          <td class="name-column">${key}</td>
          <td class="id-column">${setting.id}</td>
          <td class="value-column">${spinnerHtml}</td>
          <td class="default-column">${setting.default}</td>
          <td class="min-column">${setting.min}</td>
          <td class="max-column">${setting.max}</td>
          <td class="new-value-column"><input type="text" id="new-value-${setting.id}" /></td>
          <td class="action-column"><button onclick="updateSetting('${setting.id}')">Update</button></td>
        `;
        settingsTableBody.appendChild(row);
      }
    }

    function log(message, isError = false) {
      const logElement = document.getElementById('log');
      const logEntry = document.createElement('div');
      logEntry.classList.add('log-entry');
      logEntry.style.color = isError ? 'red' : 'black';
      logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logElement.appendChild(logEntry);
      logElement.scrollTop = logElement.scrollHeight;
    }

    document.getElementById('connect-button').addEventListener('click', async function () {
      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [{ manufacturerData: [{ companyIdentifier: 0x0A61 }] }],
          optionalServices: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e']
        });

        server = await device.gatt.connect();
        const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
        txCharacteristic = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e');
        rxCharacteristic = await service.getCharacteristic('6e400002-b5a3-f393-e0a9-e50e24dcca9e');

        await txCharacteristic.startNotifications();
        txCharacteristic.addEventListener('characteristicvaluechanged', handleNotifications);

        document.getElementById('status').textContent = 'Connected';
        document.getElementById('device-name').textContent = device.name;
        document.getElementById('disconnect-button').disabled = false;

        log(`Connected to device: ${device.name}`);

        // Load available settings files (instead of loading automatically)
        loadAvailableSettings();
      } catch (error) {
        log(`Error: ${error.message}`, true);
      }
    });

    document.getElementById('disconnect-button').addEventListener('click', function () {
      if (device && device.gatt.connected) {
        device.gatt.disconnect();
        document.getElementById('status').textContent = 'Disconnected';
        document.getElementById('device-name').textContent = '';
        document.getElementById('disconnect-button').disabled = true;
        document.getElementById('settings-selection').style.display = 'none'; // Hide settings dropdown and button
        log('Disconnected from device');
        document.querySelector('#settings-table tbody').innerHTML = '';
        document.getElementById('log').innerHTML = '';
      }
    });

    async function handleNotifications(event) {
      const value = event.target.value;
      const data = new Uint8Array(value.buffer);

      log(`Raw data received: [${Array.from(data).map(byte => '0x' + byte.toString(16).padStart(2, '0')).join(', ')}]`);

      const port = data[0];
      if (port === 3) {
        decodeSettingResponse(data);
      } else {
        log("No decoder available for this port", true);
      }
    }

    function decodeSettingResponse(data) {
      const settingId = data[1];
      const length = data[2];
      const valueBytes = data.slice(3, 3 + length);
      const settingKey = findSettingById(settingId);

      if (!settingKey) {
        log(`Setting with ID 0x${settingId.toString(16).padStart(2, '0')} not found`, true);
        return;
      }

      let value;
      const setting = settingsData.settings[settingKey];

      // Handling different data types
      if (setting.conversion === 'uint32') {
        value = new DataView(new Uint8Array(valueBytes).buffer).getUint32(0, true);
      } else if (setting.conversion === 'uint16') {
        value = new DataView(new Uint8Array(valueBytes).buffer).getUint16(0, true);
      } else if (setting.conversion === 'uint8') {
        value = valueBytes[0];
      } else if (setting.conversion === 'int32') {
        value = new DataView(new Uint8Array(valueBytes).buffer).getInt32(0, true);
      } else if (setting.conversion === 'int8') {
        value = new DataView(new Uint8Array(valueBytes).buffer).getInt8(0);
      } else if (setting.conversion === 'bool') {
        value = valueBytes[0] !== 0;
      } else if (setting.conversion === 'byte_array') {
        value = `{${Array.from(valueBytes).map(byte => '0x' + byte.toString(16).padStart(2, '0')).join(', ')}}`;
      } else if (setting.conversion === 'string') {
        value = new TextDecoder().decode(new Uint8Array(valueBytes));
      }

      log(`Decoded setting response: ${settingKey} = ${value}`);
      updateSettingDisplay(setting.id, value);
      fetchNextSetting();
    }

    function updateSettingDisplay(settingId, value, isUpdated = false) {
      const settingElement = document.getElementById(`setting-${settingId}`);
      if (settingElement) {
        const valueElement = settingElement.querySelector('.value-column');
        valueElement.innerHTML = value;
        if (isUpdated) {
          valueElement.classList.add('value-updated');
        } else {
          valueElement.classList.remove('value-updated');
        }
      }
    }

    function findSettingById(targetId) {
      for (const key in settingsData.settings) {
        const setting = settingsData.settings[key];
        const hexId = parseInt(setting.id, 16);
        if (hexId === targetId) {
          return key;
        }
      }
      return null;
    }

    async function fetchNextSetting() {
      if (currentSettingIndex >= settingsKeys.length) {
        log("All settings have been retrieved.");
        return;
      }

      const key = settingsKeys[currentSettingIndex];
      const setting = settingsData.settings[key];
      const settingId = parseInt(setting.id, 16);
      const command = [0x20, 0xa8, 0x01, settingId];
      const commandBuffer = new Uint8Array(command).buffer;

      log(`Requesting value for ${key} (ID: ${setting.id})`);

      try {
        await rxCharacteristic.writeValue(commandBuffer);
      } catch (error) {
        log(`Error sending request for ${key}: ${error.message}`, true);
      }

      currentSettingIndex++;
    }

    async function updateSetting(settingId) {
      const inputElement = document.getElementById(`new-value-${settingId}`);
      const newValue = inputElement.value.trim();

      if (!newValue) {
        log(`No new value provided for setting ID: ${settingId}`, true);
        return;
      }

      const settingKey = findSettingById(parseInt(settingId, 16));
      if (!settingKey) {
        log(`Setting with ID ${settingId} not found.`, true);
        return;
      }

      const setting = settingsData.settings[settingKey];

      // Validate input
      if (!validateInput(newValue, setting)) return;

      let valueBytes;

      if (setting.conversion === 'uint32') {
        const intValue = parseInt(newValue, 10);
        valueBytes = new Uint8Array(new Uint32Array([intValue]).buffer);
      } else if (setting.conversion === 'uint16') {
        const intValue = parseInt(newValue, 10);
        valueBytes = new Uint8Array(new Uint16Array([intValue]).buffer);
      } else if (setting.conversion === 'uint8') {
        valueBytes = new Uint8Array([parseInt(newValue, 10)]);
      } else if (setting.conversion === 'int32') {
        const intValue = parseInt(newValue, 10);
        valueBytes = new Uint8Array(new Int32Array([intValue]).buffer);
      } else if (setting.conversion === 'int8') {
        valueBytes = new Uint8Array([parseInt(newValue, 10)]);
      } else if (setting.conversion === 'bool') {
        valueBytes = new Uint8Array([newValue.toLowerCase() === 'true' ? 1 : 0]);
      } else if (setting.conversion === 'byte_array') {
        valueBytes = new Uint8Array(newValue.replace(/[{}]/g, '').split(',').map(byte => parseInt(byte, 16)));
      }

      const length = valueBytes.length;
      const command = [0x03, parseInt(settingId, 16), length, ...valueBytes];
      const commandBuffer = new Uint8Array(command).buffer;

      log(`Sending update for ${settingKey} (ID: ${settingId}) with value: ${newValue}`);

      try {
        await rxCharacteristic.writeValue(commandBuffer);
        log(`Value updated successfully for ${settingKey} (ID: ${settingId})`);
        setTimeout(() => fetchSingleSetting(settingId), 1000);
      } catch (error) {
        log(`Error sending update for ${settingKey}: ${error.message}`, true);
      }
    }

    function validateInput(newValue, setting) {
      const inputElement = document.getElementById(`new-value-${setting.id}`);

      if (setting.conversion === 'uint32' || setting.conversion === 'uint16' || setting.conversion === 'uint8' || setting.conversion === 'int32') {
        const parsedValue = parseInt(newValue, 10);
        if (isNaN(parsedValue) || parsedValue < setting.min || parsedValue > setting.max) {
          log(`Invalid value for ${setting.id}: Must be between ${setting.min} and ${setting.max}`, true);
          inputElement.classList.add('invalid');
          return false;
        }
      } else if (setting.conversion === 'bool') {
        if (newValue.toLowerCase() !== 'true' && newValue.toLowerCase() !== 'false') {
          log(`Invalid value for ${setting.id}: Must be 'true' or 'false'`, true);
          inputElement.classList.add('invalid');
          return false;
        }
      } else if (setting.conversion === 'byte_array') {
        const byteArray = newValue.replace(/[{}]/g, '').split(',');
        if (byteArray.length !== setting.length || byteArray.some(byte => isNaN(parseInt(byte, 16)))) {
          log(`Invalid byte array for ${setting.id}. Expected length: ${setting.length}`, true);
          inputElement.classList.add('invalid');
          return false;
        }
      }

      inputElement.classList.remove('invalid');
      return true;
    }

    async function fetchSingleSetting(settingId) {
      const settingKey = findSettingById(parseInt(settingId, 16));
      const setting = settingsData.settings[settingKey];
      const command = [0x20, 0xa8, 0x01, parseInt(settingId, 16)];
      const commandBuffer = new Uint8Array(command).buffer;

      log(`Re-fetching value for ${settingKey} (ID: ${settingId})`);

      try {
        await rxCharacteristic.writeValue(commandBuffer);
      } catch (error) {
        log(`Error re-fetching value for ${settingKey}: ${error.message}`, true);
      }
    }
  </script>
</body>
</html>

