<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenCollar Edge BLE Web Connect</title>
  <link rel="stylesheet" href="style.css" />
  <script src="functions.js"></script>
</head>

<body>
  <div id="header-section">
    <h1>OpenCollar Edge BLE Web Connect</h1>

    <div class="controls">
      <button id="connect-button">Connect to Device</button>
      <button id="disconnect-button" disabled>Disconnect</button>
      <label>PIN:
      <input name="pincode" id="pincode" type="text" class="pincode" value="0000" inputmode="numeric" maxlength="4"></label>
      <div id="settings-selection" style="display:none;">
        <label for="settings-dropdown">Choose a settings file:</label>
        <select id="settings-dropdown"></select>
        <button id="load-settings-button">Load setting.json</button> <!-- Load button -->

        <br>
        <button id="export-button" onclick="exportToJson()">Export</button>
        <button id="import-button" onclick="importFromJson()">Import</button>
        <input type="file" id="import-file" />
      </div>
      <div id="errors"></div>
      <div id="container">
      </div>
    </div>

    <button class="toggle-button" id="toggle-log">Show Log</button> <!-- Toggle button -->

    <div class="log" id="log"></div>
  </div>

  <div class="settings-section">
    <h2>Settings</h2>
    <div id="settings-progress">
      <div></div>
    </div>
    <div id="settings-section"></div>
  </div>

  <div class="commands-section">
    <h2>Commands</h2>
    <div id="commands-buttons-section"></div>
  </div>

  <script>
    const CMD_SINGLE_SETTING = 0xA8;
    const CMD_SINGLE_VALUE = 0xA3;
    const CMD_STATUS = 0xA4;
    const CMD_SEND_ALL_SETTINGS = 0xA7;
    const CMD_CHECK_PIN = 0xC2;

    const excludeFromImportExport = ['app_eui', 'device_pin', 'app_key', 'device_eui', 's_band_app_key', 's_band_network_key', 'tracker_type', 'ble_adv'];

    let device, server, txCharacteristic, rxCharacteristic;
    let readAllSettings = null;
    let autoLoaded = false;

    // Toggle log visibility
    document.getElementById('toggle-log').addEventListener('click', function () {
      const logElement = document.getElementById('log');
      if (logElement.style.display !== 'block') {
        logElement.style.display = 'block';
        this.textContent = 'Hide Log';
        logElement.scrollTop = logElement.scrollHeight;
      } else {
        logElement.style.display = 'none';
        this.textContent = 'Show Log';
      }
    });

    document.getElementById('load-settings-button').addEventListener('click', async function () {
      const selectedFile = document.getElementById('settings-dropdown').value;
      log(`Loading settings from ${selectedFile}...`);

      try {
        await loadSettings(selectedFile);
        log(`Settings from ${selectedFile} loaded successfully.`);
        displaySettings();
        displayCommands();
        await fetchAllSettings();
      } catch (error) {
        console.error(error);
        log(`Error loading settings: ${error.message}`, true);
      }
    });

    function exportToJson() {
      const settings = {};

      for (const [key, setting] of Object.entries(settingsData.settings)) {
        if (excludeFromImportExport.includes(key)) {
          continue;
        }

        const value = getInputValue(setting.id);

        if (['uint32', 'uint16', 'uint8', 'int32', 'int8', 'float'].includes(setting.conversion)) {
          settings[key] = Number(value);
        } else if (setting.conversion === 'bool') {
          settings[key] = value === 'true';
        } else {
          settings[key] = value;
        }
      }

      const json = JSON.stringify(settings, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'settings.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    async function importFromJson() {
      const fileInput = document.getElementById('import-file');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a file to import.');
        return;
      }

      console.log('Importing settings from file:', file.name);
      const reader = new FileReader();
      reader.onload = async function (event) {
        const progressContainer = document.getElementById('settings-progress');
        const progressBar = document.querySelector('#settings-progress div');
        const settingsSection = document.getElementById('settings-section');

        try {
          progressBar.style.width = `0%`;
          progressContainer.style.display = 'block';
          settingsSection.style.display = 'none';

          const importedSettings = JSON.parse(event.target.result);

          let index = 0;
          const entries = Object.entries(importedSettings).filter(([key]) => !excludeFromImportExport.includes(key));

          for (const [key, value] of entries) {
            index++;

            const settingObj = getByKey(key);
            if (settingObj) {
              await updateBleSetting(settingObj.id, value);
            }
            progressBar.style.width = `${(index / entries.length) * 100}%`;
          }

          await fetchAllSettings();
        } catch (error) {
          console.error('Error importing settings:', error);
          alert('Failed to import settings. Please check the file format.');
        } finally {
          settingsSection.style.display = 'block';
          progressContainer.style.display = 'none';
        }
      };
      reader.readAsText(file);
    }

    function loadAvailableSettings() {
      try {
        populateSettingsIntoPage();
        document.getElementById('settings-selection').style.display = 'block'; // Show the dropdown and load button
      } catch (error) {
        log(`Error fetching settings files: ${error.message}`, true);
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function decodeHwFwType(t) {
      switch (t) {
        case 0: return "default";
        case 1: return "rhinoedge";
        case 2: return "elephantedge";
        case 3: return "wisentedge";
        case 4: return "cattracker";
        case 5: return "rangeredge";
        case 6: return "rhinopuck";
        default: return "unknown";
      }
    }

    function decodeReset(reset) {
      switch (reset) {
        case 1: return "RESETPIN";
        case 2: return "DOG";
        case 4: return "SREQ";
        case 8: return "LOCKUP";
        default: return "unknown";
      }
    }


    function decodeStatusMessage(bytes) {
      function decode_uint8(byte, min, max) {
        var val;
        val = byte * (max - min) / 255 + min;
        return val;
      }
      // Skip header 0 and 1
      var reset = bytes[2];
      var err = bytes[3];
      var bat = (bytes[4] * 10) + 2500;
      var operation = bytes[5];
      var msg = 0;
      if (operation & 1) msg = 1;
      var locked = 0;
      if (operation & 2) locked = 1;
      var lr_join = 0;
      if (operation & 4) lr_join = 1;
      var lr_sat = operation >> 4;
      var temp = decode_uint8(bytes[6], -100, 100);
      var uptime = bytes[7];
      var acc_x = decode_uint8(bytes[8], -100, 100);
      var acc_y = decode_uint8(bytes[9], -100, 100);
      var acc_z = decode_uint8(bytes[10], -100, 100);
      var version = bytes[11];
      var ver_hw_minor = version & 0x0F;
      var ver_hw_major = version >> 4;
      version = bytes[12];
      var ver_fw_minor = version & 0x0F;
      var ver_fw_major = version >> 4;
      var ver_hw_type = bytes[13] & 0x0F;
      var ver_fw_type = bytes[13] >> 4;
      var chg = 0;
      if (bytes[14] > 0) chg = (bytes[14] * 100) + 5000;
      var features = bytes[15];
      var sat_support = 0;
      if (features & 1) sat_support = 1;
      var rf_scan = 0;
      if (features & 2) rf_scan = 1;
      var fence = 0;
      if (features & 4) fence = 1;
      var sat_try = features >> 4;
      //Errors
      var err_lr = 0;
      if (err & 1) err_lr = 1;
      var err_ble = 0;
      if (err & 2) err_ble = 1;
      var err_ublox = 0;
      if (err & 4) err_ublox = 1;
      var err_acc = 0;
      if (err & 8) err_acc = 1;
      var err_bat = 0;
      if (err & 16) err_bat = 1;
      var err_ublox_fix = 0;
      if (err & 32) err_ublox_fix = 1;
      var err_flash = 0;
      if (err & 64) err_flash = 1;
      return {
        reset: reset,
        bat: bat,
        chg: chg,
        temp: temp,
        uptime: uptime,
        locked: locked,
        msg: msg,
        acc_x: acc_x,
        acc_y: acc_y,
        acc_z: acc_z,
        lr_sat: lr_sat,
        err_lr: err_lr,
        err_lr_join: lr_join,
        err_ble: err_ble,
        err_ublox: err_ublox,
        err_acc: err_acc,
        err_bat: err_bat,
        err_ublox_fix: err_ublox_fix,
        err_flash: err_flash,
        ver_fw_major: ver_fw_major,
        ver_fw_minor: ver_fw_minor,
        ver_hw_major: ver_hw_major,
        ver_hw_minor: ver_hw_minor,
        ver_hw_type: ver_hw_type,
        ver_fw_type: ver_fw_type,
        sat_support: sat_support,
        sat_try: sat_try,
        rf_scan: rf_scan,
        fence: fence,
      };
    }

    function displayStatusMessage(statusMessage) {
      const errorsDiv = document.querySelector('#errors');
      errorsDiv.innerHTML = '';

      // Display error key only if true
      let hasErrors = false;
      for (const [key, hasError] of Object.entries(statusMessage)) {
        if (key.startsWith('err_') && hasError) {
          if (!hasErrors) {
            errorsDiv.innerHTML = 'Errors: ';
            hasErrors = true;
          }

          errorsDiv.innerHTML += `<span>${key.slice(4).toUpperCase()}</span>,`;
        }
      }

      if (hasErrors) {
        errorsDiv.innerHTML = errorsDiv.innerHTML.slice(0, -1); // Remove trailing comma
      } else {
        errorsDiv.innerHTML = 'No errors';
      }

      // Display decoded values in table
      const infoContainer = document.querySelector('#container');
      infoContainer.innerHTML = ''; // clear previous content

      infoContainer.innerHTML += `
        <div class="section">
          <h4>Device Info</h4>
          <div class="data-item"><span>Device name:</span><span>${device.name}</span></div>
          <div class="data-item"><span>Hardware Version:</span><span>${statusMessage.ver_hw_major}.${statusMessage.ver_hw_minor}</span></div>
          <div class="data-item"><span>Firmware Version:</span><span>${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}</span></div>
          <div class="data-item"><span>Hardware Type:</span><span>${decodeHwFwType(statusMessage.ver_hw_type)}</span></div>
          <div class="data-item"><span>Firmware Type:</span><span>${decodeHwFwType(statusMessage.ver_fw_type)}</span></div>
          <div class="data-item"><span>LR Sat:</span><span>${statusMessage.lr_sat}</span></div>
          <div class="data-item"><span>Msg:</span><span>${statusMessage.msg}</span></div>
        </div>
      `;

      infoContainer.innerHTML += `
        <div class="section">
          <h4>General Information</h4>
          <div class="data-item"><span>Reset:</span><span>${decodeReset(statusMessage.reset)}</span></div>
          <div class="data-item"><span>Battery:</span><span>${statusMessage.bat}mV</span></div>
          <div class="data-item"><span>Charging:</span><span>${statusMessage.chg}</span></div>
          <div class="data-item"><span>Locked:</span><span>${statusMessage.locked}</span></div>
          <div class="data-item"><span>Temperature:</span><span>${statusMessage.temp.toFixed(2)}°C</span></div>
          <div class="data-item"><span>Uptime:</span><span>${statusMessage.uptime} days</span></div>
          <div class="data-item"><span>Acceleration:</span><span>${statusMessage.acc_x.toFixed(2)}, ${statusMessage.acc_y.toFixed(2)}, ${statusMessage.acc_z.toFixed(2)}</span></div>
        </div>
      `;
    }

    function displaySettings() {
      const settingsSection = document.getElementById('settings-section');
      settingsSection.innerHTML = '';
      for (const [groupName, group] of Object.entries(groupAndSortSettings(settingsData.settings))) {
        const settingsContainer = document.createElement('div');
        settingsContainer.className = 'settings-container';

        const groupHeading = document.createElement('h3');
        groupHeading.textContent = groupName.replace(/_/g, "");
        settingsSection.appendChild(groupHeading);

        for (const [key, setting] of Object.entries(group)) {
          const row = document.createElement('div');
          row.className = 'setting disabled';
          row.setAttribute('id', `setting-${setting.id}`);
          row.innerHTML = `
          <h4>${key} (${setting.id})</h4> 
          
          ${renderInput(key, setting)}

          <div>
            <button id="update-button-${setting.id}" onclick="updateSetting('${setting.id}')">Update</button>
            <button id="reset-button-${setting.id}" onclick="setDefaultValue('${setting.id}')" class="secondary" title="Default value: ${setting.default}">Set default</button>
          </div>
        `;
          settingsContainer.appendChild(row);
        }
        settingsSection.appendChild(settingsContainer);
      }
    }

    function displayCommands() {
      const commandsSection = document.getElementById('commands-buttons-section');
      commandsSection.innerHTML = '';
      for (const [key, command] of Object.entries(settingsData.commands)) {
        if (command.length !== 0 || dangerousCommands.some(rx => rx.test(key))) {
          continue;
        }

        const row = document.createElement('div');
        row.className = 'command';
        row.setAttribute('id', `command-${command.id}`);
        row.innerHTML = `<button id="command-button-${command.id}" onclick="executeCommand('${command.id}')">${key.replace(/cmd_/g, "")}</button>`;
        commandsSection.appendChild(row);
      }
    }

    function log(message, isError = false) {
      const logElement = document.getElementById('log');
      const logEntry = document.createElement('div');
      logEntry.classList.add('log-entry');
      logEntry.style.color = isError ? 'red' : 'black';
      logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logElement.appendChild(logEntry);
      logElement.scrollTop = logElement.scrollHeight;
    }

    function autoSelectAndLoadSettings(statusMessage) {
      log("autoSelectAndLoadSettings");
      const settingsDropdown = document.getElementById('settings-dropdown');
      const fwVersion = `${statusMessage.ver_fw_major}.${statusMessage.ver_fw_minor}`;

      for (let i = 0; i < settingsDropdown.options.length; i++) {
        if (settingsDropdown.options[i].text.includes(fwVersion)) {
          settingsDropdown.selectedIndex = i;
          document.getElementById('load-settings-button').click();
          break;
        }
      }
    }

    function onDisconnected() {
      log('Disconnected from device');
      autoLoaded = false;
      document.getElementById('errors').textContent = '';
      document.getElementById('container').textContent = '';
      document.getElementById('disconnect-button').disabled = true;
      document.getElementById('connect-button').disabled = false;
      document.getElementById('settings-selection').style.display = 'none'; // Hide settings dropdown and button
      document.getElementById('settings-section').innerHTML = '';
      document.getElementById('commands-buttons-section').innerHTML = '';
    }

    document.getElementById('connect-button').addEventListener('click', async function () {
      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [{ manufacturerData: [{ companyIdentifier: 0x0A61 }] }],
          optionalServices: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e']
        });

        device.addEventListener('gattserverdisconnected', onDisconnected);
        server = await device.gatt.connect();

        const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
        txCharacteristic = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e');
        rxCharacteristic = await service.getCharacteristic('6e400002-b5a3-f393-e0a9-e50e24dcca9e');

        await txCharacteristic.startNotifications();
        txCharacteristic.addEventListener('characteristicvaluechanged', handleNotifications);

        document.getElementById('connect-button').disabled = true;
        document.getElementById('disconnect-button').disabled = false;

        log(`Connected to device: ${device.name}`);

        // Load available settings files
        loadAvailableSettings();

        await checkPin(document.getElementById('pincode').value);
      } catch (error) {
        log(`Error: ${error.message}`, true);
      }
    });

    document.getElementById('disconnect-button').addEventListener('click', function () {
      if (device && device.gatt.connected) {
        device.gatt.disconnect();
      }
    });

    async function handleNotifications(event) {
      const value = event.target.value;
      const data = new Uint8Array(value.buffer);

      log(`Raw data received: ${bytesToHex(data)}`);

      const port = data[0];
      try {
        if (port === 31 && data.length >= 5 && data[1] === 0xF3 && data[3] === CMD_CHECK_PIN && data[4] === 0x01) {
          log(`PIN OK`);
          await requestStatusMessage();
        } else if (port === 3) {
          decodeBleValueResponse(data.slice(1));
        } else if (port === 4) {
          const statusMessage = decodeStatusMessage(data.slice(1));
          displayStatusMessage(statusMessage);
          if (!autoLoaded) {
            autoLoaded = true;
            autoSelectAndLoadSettings(statusMessage);
          }
        } else {
          decodeMessage(data);
        }
      } catch (error) {
        console.error(error);
        log(`Error decoding response: ${error.message}`, true);
      }
    }

    function decodeMessage(data) {
      const port = data[0];
      const portName = Object.keys(settingsData.ports).find(key => settingsData.ports[key] === port);
      if (portName) {
        const id = data[1];
        const message = Object.entries(settingsData.messages).find(([key, msg]) => msg.port === portName && msg.id.toUpperCase() === `0x${id.toString(16)}`.toUpperCase());
        if (message) {
          const [key, msg] = message;
          const valueBytes = data.slice(3, 3 + msg.length);
          log(`Decoded message: ${key} = ${bytesToHex(valueBytes)}`);
        } else {
          throw new Error(`No message found for port: ${portName} and id: 0x${id.toString(16)}`);
        }
      } else {
        throw new Error('No decoder available for port: ' + port);
      }
    }

    function decodeBleValueResponse(bytes) {
      for (let i = 0; i < bytes.length;) {
        const id = bytes[i++];
        const len = bytes[i++];
        const valueBytes = bytes.slice(i, i + len);

        const [key, setting] = getById(id);
        let value = bytesToSetting(setting, valueBytes);
        log(`Decoded setting response: ${key} = ${value}`);
        updateSettingDisplay(setting.id, value);
        i += len;
      }
    }

    function arraysEqual(arr1, arr2) {
      // Check if lengths are different
      if (arr1.length !== arr2.length) {
        return false;
      }

      // Check if all elements are equal
      return arr1.every((element, index) => element === arr2[index]);
    }

    function isValueNotDefault(settingId, value) {
      const [key, valueMeta] = getById(settingId);
      if (valueMeta.conversion === 'byte_array') {
        return !arraysEqual(stringToUint8Array(value, valueMeta.length), stringToUint8Array(stripBytes(valueMeta.default), valueMeta.length));
      }
      return value !== valueMeta.default;
    }

    function updateSettingDisplay(settingId, value) {
      setInputValue(settingId, value);

      const rowElement = document.getElementById(`setting-${settingId}`);
      if (rowElement) {
        rowElement.classList.remove('disabled');
        if (isValueNotDefault(settingId, value)) {
          rowElement.classList.add('value-not-default');
        } else {
          rowElement.classList.remove('value-not-default');
        }
      }
    }

    async function requestBleValue(id, cmd) {
      if (typeof id === 'string' || id instanceof String) {
        id = parseInt(id, 16);
      }

      return executeBleCommand([0x20, cmd, 0x01, id]);
    }

    async function executeCommand(cmd) {
      if (typeof cmd === 'string' || cmd instanceof String) {
        cmd = parseInt(cmd, 16);
      }

      return executeBleCommand([0x20, cmd, 0x00]);
    }

    async function requestStatusMessage() {
      return executeBleCommand([0x20, CMD_STATUS, 0x00])
    }

    async function checkPin(pin_in) {
      // add zeros to each number in PIN ("1234" -> "01020304")
      let pin_out = "0" + pin_in.split("").join("0");
      // add zeros to the end (to have 16 byte data length)
      pin_out = pin_out + "000000000000000000000000";
      return executeBleCommand([0x20, CMD_CHECK_PIN, 16, ...stringToUint8Array(pin_out, 16)]);
    }

    async function requestAllSettings() {
      return executeBleCommand([0x20, CMD_SEND_ALL_SETTINGS, 0x00])
    }

    async function executeBleCommand(command) {
      log(`Sending command ${bytesToHex(command)}`);

      const commandBuffer = new Uint8Array(command).buffer;
      try {
        await rxCharacteristic.writeValue(commandBuffer);
      } catch (error) {
        log(`Error sending command: ${error.message}`, true);
      }
    }

    async function fetchAllSettings() {
      await requestAllSettings();
    }

    async function updateBleSetting(settingId, newValue) {
      const [settingKey, setting] = getById(settingId);

      let valueBytes = settingToBytes(setting, newValue);

      const length = valueBytes.length;
      const command = [0x03, parseInt(settingId, 16), length, ...valueBytes];
      const commandBuffer = new Uint8Array(command).buffer;

      log(`Sending update for ${settingKey} (ID: ${settingId}) with value: ${newValue}`);

      try {
        await rxCharacteristic.writeValue(commandBuffer);
        log(`Value updated successfully for ${settingKey} (ID: ${settingId})`);
      } catch (error) {
        log(`Error sending update for ${settingKey}: ${error.message}`, true);
        throw error;
      }
    }

    async function updateSetting(settingId) {
      const rowElement = document.getElementById(`setting-${settingId}`);
      try {
        rowElement.classList.add('disabled');
        await updateBleSetting(settingId, getInputValue(settingId));
        await sleep(1000);
        await requestBleValue(settingId, CMD_SINGLE_SETTING);
      } finally {
        rowElement.classList.remove('disabled');
      }
    }
  </script>
</body>

</html>